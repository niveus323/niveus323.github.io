{"pages":[{"title":"About Me","text":"Haeng Lee.","link":"/about/index.html"}],"posts":[{"title":"백준 1005번 문제 - ACMCRAFT","text":"문제 링크 : https://www.acmicpc.net/problem/10051005번 문제는 특정 건물을 건설하는데 있어 건설해야할 건물이 존재한다는 점, 동시 건설이 가능하다는 점에 주목하여 문제를 풀어야 한다. 특히 동시 건설의 경우 오래 걸리는 시간에 의해 전체 건설 시간이 결정되므로 임의의 건물이 필요로한 건물들을 건설하는 데 걸리는 시간들 중 최대 값을 기준으로 계산하여 구현해야 한다. 특정 건물을 건설하기 위해서는 요구되는 건물들을 모두 건설하여야 하므로 최소시간은 중복 건설이 일어나지 않는다면 요구되는 건물들의 동시 건설에 의하여 찾을 수 있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243//1005#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;#define MAXSIZE 1001int D[MAXSIZE]={0};//건물 건설 시간vector&lt;int&gt; required[MAXSIZE]; //요구되는 건물 리스트int time[MAXSIZE]={0};//동적 계획법을 이용하여 반복되는 계산을 방지int T,N,K;//테스트케이스 T, 건물 수 N, 건물 순서 규칙 수 Kint build(int w){ if(time[w]!=-1) return time[w]; //미리 계산된 건설시간이 있다면 시간을 절약할 수 있음 if(required[w].empty()) return time[w] = D[w]; //요구 건물이 없을 경우 건설 int max=0, calculated=0; for(int i=0;i&lt;required[w].size();i++){ //건물 w를 건설하기 위해 필요한 건물 리스트업 calculated = build(required[w][i]); //임의의 요구 건물을 건설하는데 걸리는 시간 계산 if(calculated&gt;max) max = calculated; //동시 건설시 결정되는 시간 } return time[w] = max + D[w]; //요구 건물의 동시건설시간 + 건물 W의 건설시간 = 전체 건설시간}int main(){ int X,Y; scanf(\"%d\",&amp;T); while(T--){ scanf(\"%d %d\",&amp;N,&amp;K); for(int i=1;i&lt;=N;i++){//각 테스트케이스마다 초기화 필요 required[i].clear(); time[i]=-1; scanf(\"%d\",&amp;D[i]);//건물 건설 시간 D } while(K--){ //건물 건설 순서 규칙 scanf(\"%d %d\",&amp;X,&amp;Y); required[Y].push_back(X); } //목표 건물 W int W; scanf(\"%d\",&amp;W); printf(\"%d\\n\",build(W)); } return 0;}","link":"/2020/07/06/CodingTest/BOJ-1005/"},{"title":"백준 1009번 문제 - 분산처리","text":"문제 링크 : https://www.acmicpc.net/problem/1009분산처리 문제는 어려워보이는 제목과는 달리 컴퓨터가 10대라는 점만으로 해결방법을 알 수 있는 쉬운 문제이다. 1번째 컴퓨터는 1번째 데이터, 11번째 데이터, 21번째 데이터와 같이 일의 자리가 1인 번호의 데이터를 처리하며 $a^b$개의 데이터 중 마지막 데이터는 일의 자리에 따라 처리할 컴퓨터의 번호가 결정된다. 그러나 $1\\leq a &lt; 100 , 1\\leq b &lt; 1,000,000$의 조건으로 보아 단순히 $a^b$를 계산하여 일의 자리를 찾는 것은 무리가 있어보인다. 이때 생각해야 할 것이 “일의 자리의 규칙성”이다. 예를 들어, $3^7$의 데이터에 대하여 생각해보자. $3^1=3$, $3^2=9$, $3^3=27$, $3^4=81$, $3^5=243$, $3^6=729$, $3^7=2187$로 일의자리가 3 -&gt; 9 -&gt; 7 -&gt; 1의 반복이 이루어짐을 확인할 수 있다. 10 이하의 자연수에 대하여 지수함수의 일의 자리는 최대 4가지 경우의 수가 존재하며, 11 이상의 자연수는 일의 자리에 대해서만 계산하므로 10 이하의 자연수와 동일한 결과를 얻는다. 따라서 $a^b$의 일의 자리는 ${(a \\mod 10)}^{b} \\mod 10$이며 일의 자리의 반복 중 $b \\mod 4$번째 결과와 동일한 결과를 갖는다. 1234567891011121314151617#include&lt;iostream&gt;using namespace std;int arr[4];int main(){ int T,a,b; scanf(\"%d\",&amp;T); while(T--){ scanf(\"%d %d\",&amp;a,&amp;b); arr[0]=a%10; arr[1]=(arr[0]*a)%10; arr[2]=(arr[1]*a)%10; arr[3]=(arr[2]*a)%10; printf(\"%d\\n\",(arr[(b-1)%4]==0)?10:arr[(b-1)%4]); } return 0;}","link":"/2020/07/07/CodingTest/BOJ-1009/"},{"title":"백준 1018번 문제 - 체스판 다시 칠하기","text":"문제 링크: https://www.acmicpc.net/problem/1018체스판 다시 칠하기 문제는 8x8 크기의 체스판으로 만들 때 체스판의 경우의 수가 좌상단 첫번째 칸이 흰색인 경우와 검은색인 경우 두가지 밖에 없다는 점을 읽었다면 쉽게 풀 수 있는 문제이다. NxM의 보드판이 주어졌을 때 8x8의 체스판을 구하기 위해 정할 수 있는 시작점은 (0,0)부터 (N-8,M-8)까지 가능하다. 가능한 각 시작점을 기준으로 8x8의 가능한 체스판 2개에 대해 불일치한 수를 구해 최소값을 구함으로서 해답을 구할 수 있다. 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;#define MAXSIZE 51#define CHESSSIZE 8int N,M,result=64;//8x8이므로 아무리 색을 다시칠해도 64의 결과가 나올 수 없음char arr[MAXSIZE][MAXSIZE];int check(int n,int m){ //8x8에서 인접한 위치와 충돌이 일어나는 수 int result1=0, result2=0; for(int i=0;i&lt;CHESSSIZE;i++){ for(int j=0;j&lt;CHESSSIZE;j++){ if(i%2==j%2){//0,0 || 1,1 if(arr[n+i][m+j]!='W') result1++; if(arr[n+i][m+j]!='B') result2++; }else{//0,1 || 1,0 if(arr[n+i][m+j]!='B') result1++; if(arr[n+i][m+j]!='W') result2++; } } } return (result1&lt;result2)?result1:result2;}int main(){ scanf(\"%d %d\",&amp;N,&amp;M); for(int i=0;i&lt;N;i++) scanf(\"%s\",&amp;arr[i]); //풀이 1: 가장 간단한 방법, N-8, M-8의 경우의 수를 전부 조사하여 최소값 구하기 for(int i=0;i&lt;=N-8;i++){//시작점 세팅 for(int j=0;j&lt;=M-8;j++){ int temp = check(i,j); result = (result&gt;temp)?temp:result; } } printf(\"%d\\n\",result);}","link":"/2020/07/11/CodingTest/BOJ-1018/"},{"title":"백준 1007번 문제 - 벡터 매칭","text":"문제 링크 : https://www.acmicpc.net/problem/1007벡터 매칭 문제는 다음의 조건을 염두에 두고 생각하여 풀 수 있는 문제이다. 모든 점은 한 번씩 쓰여야 함 벡터를 구성하는 것은 두 점 (x1, y1), (x2, y2)의 두 점으로부터 형성되는 벡터는 (x1-x2, y1-y2) 또는 (x2-x1, y2-y1)의 형태를 갖는다. 따라서 N개의 점으로 구성된 집합으로부터 얻을 수 있는 벡터 합의 크기는 N/2개의 점을 -연산, 나머지 점을 +연산하여 합한 벡터 x,y의 크기로서 표현된다. 중복 없이, N개의 점에서 N/2개의 점을 선택하므로 ${N}\\choose{\\frac{N}{2}}$의 경우의 수가 존재하지만 N은 20 이하의 자연수라는 조건이 존재하므로 재귀함수로 모든 점을 +한 결과와 -한 결과의 비교를 통해서 최소 값을 구하여 풀 수 있다. 또한 (x1-x2, y1-y2)의 길이와 (x2-x1, y2-y1)의 길이는 모두 $\\sqrt{(x1-x2)^2+(y1-y2)^2}$으로 같으므로 첫번째 점을 +연산으로 가정하여 풀어도 첫번째 점을 -연산하여 계산한 최소값과 동일한 결과를 얻을 수 있다.12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;#define MAXSIZE 21int T,N;int x[MAXSIZE],y[MAXSIZE],c[MAXSIZE];//배열 c: +연산시 1, -연산시 -1double result;void combination(int n,int index){ if(index==N) return; if(n==N/2){ //-연산을 할 점을 모두 결정하였다면 벡터 합의 크기를 계산하여 비교 double sum_x=0,sum_y=0; for(int i=0;i&lt;N;i++){ sum_x += c[i]*x[i]; //벡터 합의 x좌표 sum_y += c[i]*y[i]; //벡터 합의 y좌표 } double temp = sqrt((sum_x*sum_x)+(sum_y*sum_y)); if(temp&lt;result) result = temp; return; } combination(n,index+1); //다음 인덱스에 대해 +연산을 한 결과로 비교 c[index]=-1; combination(n+1,index+1); //다음 인덱스에 대해 -연산을 한 결과로 비교 c[index]=1;}int main(){ scanf(\"%d\",&amp;T); while(T--){ scanf(\"%d,\",&amp;N); result=1.79E+308; //다른 테스트 케이스에 대해 영향을 미치지 않도록 초기화 for(int i=0;i&lt;N;i++){ scanf(\"%d %d\",&amp;x[i],&amp;y[i]); c[i] = 1; //모든 점을 +연산 상태로 초기화하여 계산 } combination(0,0); printf(\"%f\\n\",result); } return 0;}","link":"/2020/07/07/CodingTest/BOJ-1007/"},{"title":"백준 1012번 문제 - 유기농 배추","text":"문제 링크 : https://www.acmicpc.net/problem/1012유기농 배추 문제는 DFS 또는 BFS를 통해 해결할 수 있다. DFS란 깊이 우선 탐색(Depth-First Search), BFS란 너비 우선 탐색(Breadth-First Search)으로서 모든 정점을 한 번씩만 방문하여 모든 노드를 탐색하는 그래프 탐색 알고리즘이다. 명칭에서도 알 수 있듯이, DFS는 깊이 우선 탐색으로 더 이상 이동할 수 있는 노드가 없을 때까지 연결된 노드를 지속적으로 방문한 후 이전 노드로 돌아가 연결된 다른 노드를 방문하는 backtracking 방식을 사용하며 BFS는 너비 우선 탐색으로 노드에 가까운 노드들을 모두 방문한 후에 해당 노드들에 연결된 노드를 방문하는 방식으로 구현되어있다. DFS의 경우 깊이를 우선시 하기 위해 LIFO인 stack을 사용하거나 재귀함수를 사용하여 탐색할 수 있으며, BFS의 경우 너비를 우선시 하기 위해 FIFO인 queue를 사용한다. 유기농 배추 문제는 배추가 심어져 있는 땅의 위치 X와 Y를 입력으로 받는다.입력받은 배추들을 확인할 예정에 두고 인접한 위치에 배추가 존재하지 않을 때까지 방문하지 않은 인접 배추들을 확인하도록 하여 그룹을 체크할 수 있다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;#define MAXSIZE 51int T,M,N,K;int arr[MAXSIZE][MAXSIZE]={0};bool bvisited[MAXSIZE][MAXSIZE]={false};vector&lt;pair&lt;int,int&gt;&gt; vec;int result=0;void grouping(int x, int y){ bvisited[x][y]=true; if(x&gt;0&amp;&amp;arr[x-1][y]&amp;&amp;!bvisited[x-1][y]){ grouping(x-1,y); } if(x+1&lt;M&amp;&amp;arr[x+1][y]&amp;&amp;!bvisited[x+1][y]){ grouping(x+1,y); } if(y&gt;0&amp;&amp;arr[x][y-1]&amp;&amp;!bvisited[x][y-1]){ grouping(x,y-1); } if(y+1&lt;N&amp;&amp;arr[x][y+1]&amp;&amp;!bvisited[x][y+1]){ grouping(x,y+1); }}int main(){ scanf(\"%d\",&amp;T); while(T--){ scanf(\"%d %d %d\",&amp;M,&amp;N,&amp;K); vec.clear(); result=0; for(int i=0;i&lt;N;i++){//y for(int j=0;j&lt;M;j++){//x bvisited[i][j] = false; arr[i][j]=0; } } while(K--){ int i,j; scanf(\"%d %d\",&amp;i,&amp;j); arr[i][j] =1; vec.push_back(make_pair(i,j)); } for(int i=0;i&lt;vec.size();i++){ int x = vec[i].first; int y = vec[i].second; if(!bvisited[x][y]){ grouping(x,y); result++; } } printf(\"%d\\n\",result); } return 0;}","link":"/2020/07/12/CodingTest/BOJ-1012/"},{"title":"백준 1021번 문제 - 회전하는 큐","text":"문제 링크 : https://www.acmicpc.net/problem/1021회전하는 큐 문제는 다음과 같은 3가지 연산을 수행한다. 1. 첫 번째 원소를 뽑아낸다. 2. 원소들을 좌측으로 한 칸씩 이동시킨다. 3. 원소들을 우측으로 한 칸씩 이동시킨다. 2번 연산 이후 3번 연산을 사용하게 된다면 원소는 제자리로 돌아가게 될 것이다. 따라서 원소를 뽑아내는데 필요한 2, 3번 연산의 최소 값은 원하는 원소가 첫 번째 원소가 될 때 까지 2번 연산을 수행하거나 3번 연산을 수행하는 경우 중 수행한 연산의 최소 값이 된다. (원소의 위치)와 (원소의 위치 - 큐의 크기)의 계산으로 이를 확인하였으며 구현한 내용은 아래와 같다. 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int N,M,result=0;vector&lt;int&gt; vec;void myPop(int k){ int current = 0; while(vec[current]!=k) current++; //뽑아내고자 하는 원소의 위치 확인 if(current&lt;vec.size()-current){//2번 연산 while(vec.front()!=k){ vec.push_back(vec.front()); vec.erase(vec.begin()); result++; } }else{//3번 연산 while(vec.front()!=k){ vec.insert(vec.begin(),vec.back()); vec.pop_back(); result++; } } vec.erase(vec.begin());//1번 연산}int main(){ scanf(\"%d %d\",&amp;N,&amp;M); for(int i=1;i&lt;=N;i++){ vec.push_back(i); } for(int i=0;i&lt;M;i++){ int k; scanf(\"%d\",&amp;k); myPop(k); } printf(\"%d\\n\",result); return 0;}","link":"/2020/07/26/CodingTest/BOJ-1021/"},{"title":"Spring Ch 1. IoC 컨테이너(2) -  Component와 Autowired","text":"Component Component-scan에 의해 Bean으로 등록되는 개발자가 직접 작성한 클래스. @Controller, @Service, @Repository는 @Component를 확장한 annotation이며 이러한 Annotation이 등록된 컴포넌트들은 컨테이너에 의해 의존성이 주입된다. ComponentScan에는 아래와 같이 다양한 설정들이 있다. basePackages 기본적으로 컴포넌트 스캔은 basePackage로 등록된 클래스를 기준으로 하여 작동한다. 컴포넌트 스캔은 등록된 클래스가 존재하는 폴더부터 하위폴더로 진행되므로 상위 폴더에 대해서는 스캔 되지 않는다. basePackage의 기본값은 component-scan을 사용하는 configuration 설정 파일의 폴더. useDefaultFilters useDefaultFilters의 기본 값은 true이며 Annotation이 사용된 객체를 컨테이너에 등록한다. useDefaultFilters의 값을 false로 설정할 경우 @Component 어노테이션을 컨테이너에서 제외하고 @Controller 어노테이션이 등록된 클래스만을 등록한다. includeFilters와 excludeFilters 특정 Component Annoation에 대한 설정을 할 수 있다. 컨테이너는 Filter의 조건을 만족하는 클래스를 추가/제외하며 다음의 필터 타입 지정을 할 수 있다. ANNOTATION: 특정 어노테이션에 대해 필터를 적용한다. ASPECTJ: 특정 package의 객체에 대해 필터를 적용한다. ASSIGNABLE_TYPE: 특정 클래스에 대해 필터를 적용한다. REGEX: 글자가 포함된 package와 객체명에 대해 필터를 적용한다. CUSTOM: TypeFiler 인터페이스로 작성한 필터를 적용한다.12345678910111213@ComponentScan( basePackages = \"com.package\", useDefaultFilters = false, includeFilters={ @Filter( type = FilterType.ANNOTATION, classes = {Component.class, Repository.class} //@component, @Repository 어노테이션이 적용된 개체를 추가한다. ) })public class Config{ ...} Annotation 클래스, 메소드, 객체에 특정 의미를 부여하는 자바 구문. 자바 코드에 @로 시작하는 구문을 주석처럼 달아 의존성 주입이 가능하도록 한다. Annotation은 Bean의 등록에 있어 Xml을 통한 등록보다 낮은 우선순위를 갖는다. ※ Xml과 Annotation의 비교 xml configuration file을 사용한 빈의 등록은 xml파일의 수정만으로도 빈 설정을 변경할 수 있지만 등록하고자하는 빈이 많아질 경우 수정이 쉽지 않다는 단점이 나타난다. Annotation은 애플리케이션에 등록된 Bean과 의존관계를 한눈에 볼 수 없다는 단점이 있지만 소스코드와 메타데이터가 결합되므로 XML문서에 접근하지 않고도 빈의 등록이 가능해 편리하다. 시스템 전반에 영향을 주고 이후 변경 가능성이 있는 메타데이터는 코드로부터 분리되는 것이 유지보수성에 좋다. (xml로 등록) 변경 가능성이 없는 메타데이터는 Annotation 기반의 Bean 설정으로 생산성을 향상 시키는 것이 좋다. Autowired 각 타입에 맞는 Bean을 IoC컨테이너로부터 찾아 주입하는 annotation. 생성자, set함수, 필드에 Autowired 어노테이션을 붙여 사용할 수 있으며 스프링 4.3버전부터는 생성자에 Autowired를 붙이지 않아도 객체가 주입된다. 12345678910111213141516@Servicepublic class Service{ @Autowired //필드 객체의 Injection private Repository repository; @Autowired //Set함수의 Injection public void setRepository(Repository repository){ this.repository = repository; } //@Autowired //생성자의 Injection (생략 가능) public Service(Repository repository){ this.repository = repository; }}","link":"/2020/11/02/Spring/spring-2/"},{"title":"백준 1032번 문제 - 명령 프롬프트","text":"문제 링크 : https://www.acmicpc.net/problem/1032명령 프롬프트 문제는 주어진 문자열들을 비교하여 불일치가 발생한 문자에 대해 ?로 표현하여 출력하는 문제이다. 하나의 문자열이라도 불일치가 발생한 경우 불일치가 발생한 위치의 문자는 ?로 출력되므로비교할 기준이 되는 문자열 하나만을 저장하여 다른 문자열들과 비교하고 불일치가 발생한 위치의 문자를 ?로 변경한다면 공간적인 낭비를 줄일 수 있다. 또한 문자열의 길이 최대 값은 50이지만 그보다 작은 길이의 문자열 입력이 발생할 수 있다. scanf 함수를 통해서 입력 받은 문자열의 마지막 문자는 NULL(‘\\0’)이 입력되므로 (i&lt;51 &amp;&amp; arr[i] != NULL) 혹은 (i&lt;51 &amp;&amp; arr[i])의 조건문을 수행한다면 &amp;&amp;연산에 의하여 i&lt;51을 만족하지 않는다면 뒤의 연산을 수행하지 않기 때문에 문자열 길이 내의 검사를 수행할 수 있다. 12345678910111213141516171819#include&lt;iostream&gt;using namespace std;#define MAXSIZE 51int N;char arr[MAXSIZE], temp[MAXSIZE];int main(){ scanf(\"%d\",&amp;N); scanf(\"%s\",&amp;arr); for(int i=1;i&lt;N;i++){ scanf(\"%s\",temp); int j=0; while(j&lt;MAXSIZE &amp;&amp; temp[j]){ if(arr[j]!=temp[j]) arr[j] = '?'; j++; } } printf(\"%s\\n\",arr);}","link":"/2020/08/05/CodingTest/BOJ-1032/"},{"title":"백준 1037번 문제 - 약수","text":"문제 링크 : https://www.acmicpc.net/problem/1037N의 약수들은 제곱으로 N이 되는 약수를 제외하고 대칭이 되는 숫자들끼리 곱하여 N을 구할 수 있다. 예를 들어, 16의 경우 약수들은 {1, 2, 4, 8, 16}으로 16을 구하기 위해 1과 16, 2와 8, 4(제곱)을 선택하여야 한다. N의 약수들이 주어졌을 때, N은 최소값과 최대값을 저장하여 곱함으로서 구할 수 있고 이는 다른 최대, 최소 값을 제외하고 저장할 필요가 없다는 것을 의미한다. 그러나 주어지는 약수들은 1,000,000이하의 정수로 입력되는 점을 고려하였을 때, 두 정수의 곱으로 표현되는 정수 N은 16비트로 표현되는 int형 정수가 아닌 32비트 정수로 표현하여야 한다. 32비트 정수를 표현하기 위해 최소 약수와 최대 약수의 곱은 long long int형 정수로 형변환을 하여 출력되도록 하였다. 1234567891011121314#include&lt;stdio.h&gt;using namespace std;int aliqot, N, alimin=1000000,alimax=1;int main(){ scanf(\"%d\",&amp;N); while(N--){ scanf(\"%d\",&amp;aliqot); alimin = (aliqot&lt;alimin)?aliqot:alimin; alimax = (aliqot&gt;alimax)?aliqot:alimax; } printf(\"%lld\",(long long int)alimin*alimax); return 0;}","link":"/2020/08/14/CodingTest/BOJ-1037/"},{"title":"Spring - 중복된 빈 등록에 대한 처리","text":"스프링 의존 객체 선택 컴포넌트 Annotation은 싱글톤 범위로 등록되며 같은 타입의 빈이 다른 클래스에서 등록된 경우 에러가 발생한다.12345678910111213public interface Repository {}@Repositorypublic class Repository2 implements Repository{}@Repository public class Repository3 implements Repository{}@Servicepublic class Service{ @Autowired //등록된 빈이 중복되어 에러 발생 Repository repository;} 해결방법 1. @Primary Annotation을 추가하여 우선순위를 지정 우선순위로 클래스를 등록하도록 선택한다. @Primary 어노테이션 또한 두번 이상 사용될 경우 에러가 발생하므로 주의하여야 한다.123@Repository @Primary //객체 선택에 우선순위를 지정public class Repository2 implements Repository{} 해결방법 2. @Qualifier Annotation을 설정하여 조건 설정 해당 bean이 사용할 의존 객체를 선택할 수 있게 한다. Configuration 파일에서 qualifier태그를 통해 빈의 한정자 값을 설정하고 @Qualifier 어노테이션으로 선택할 한정자를 등록하는 빈들의 의존성을 직접 관리할 수 있는 경우에 한하여 사용하는 것이 적절하다. (한정자 값을 갖는 빈 객체가 존재하지 않으면 에러가 발생하기 때문)123&lt;bean id=\"repository\" calss=\"com.example.Repository\"&gt; &lt;qualifier value=\"id\"/&gt;&lt;/bean&gt; 1234public class Component{ @Autowired @Qualifier(\"id\")//id라는 한정자를 갖는 객체를 컨테이너로부터 주입받는다. private Repository repository;} 해결방법 3. 해당 타입의 Bean을 하나의 배열에 모두 주입받기 List array로 객체를 선언하여 빈에 해당하는 객체를 모두 주입받을 수 있다. 하나의 배열에 동일한 관리를 요할 때 사용할 수 있음.12345@Servicepublic class Service{ @Autowired //등록된 다수의 Repository 객체를 모두 배열에 주입 List&lt;Repository&gt; repositories;} 해결 방법 4. Autowired로 주입받는 객체의 이름을 인터페이스가 아닌 클래스의 id로 설정하기 Bean이 다수의 클래스에 의해 등록되어도 @Autowired 어노테이션이 붙은 객체의 이름이 특정 클래스의 이름과 동일하다면 해당 클래스의 객체로 주입된다. 이러한 방법의 경우 재활용성이 떨어지기 때문에 좋은 방법으로 사용되지는 않는다.12345@Servicepublic class Service{ @Autowired //Repository 타입의 Bean이 중복되었지만 클래스 이름이 같은 Repository3 객체가 주입된다. Repository repository3;}","link":"/2020/11/02/Spring/spring-3/"},{"title":"Spring Ch 1. IoC 컨테이너(1) -  빈과 IoC","text":"Dependency 하나의 객체가 다른 객체를 변수로 가지고 있거나 파라미터로 전달, 혹은 메소드를 호출하는 것을 ‘의존한다’라고 표현한다. 객체 A가 객체 B를 의존하고자 할 때 객체를 직접 선언하여 사용하나, 만약 객체 A가 객체 B 대신 객체 C를 사용하는 객체로 사용하기 위해서는 C에 의존하고 객체 A와 비슷한 객체 D를 선언해야 한다. Dependency Inversion Principle 의존하는 객체는 재사용할 수 없다. 객체를 재사용하기 위해서는 의존성을 제거하여야 한다. 의존 대상이 되는 객체를 추상화하여 의존성을 제거할 수 있다. 이를 의존성 역전 원리(Dependency Inversion Principle)라고 한다. IoC(Inversion of Control) 의존성 역전 원리를 구현하는 기법중 하나. 객체가 사용하는 의존 객체를 만들지 않고 주입 받아 사용하는 방식을 의미하며 이를 의존 관계 주입(Dependency Injection) 이라고도 한다. IOC 컨테이너 IOC 기능을 제공하는 외부 객체를 IOC 컨테이너라고 한다. IOC 컨테이너를 통해 객체의 생성, 설정, 제거 등의 작업을 수행하기 때문에 컨테이너가 객체의 제어권을 가지고 있다. 123456789101112131415161718//일반적인 제어public class Service{ Repository repository = new Repository();}//IoC에서의 제어@Repositorypublic class Repository{ }@Servicepublic class Service{ Repository repository; @autowired public void setRepository(Repository repository){ this.repository = repository; }} Bean IOC 컨테이너가 관리하는 객체. 컨테이너에서 객체를 주입받으므로 별도의 new 연산자를 필요로 하지 않는다. XML을 이용한 빈 등록 Spring Framework에서 xml configuration file을 생성하여 빈을 등록할 수 있다. Eclipse 환경에서는 New File -&gt; Others -&gt; Spring Bean Configuration File를 통해 생성. 생성한 Configuration File을 다음과 같이 작성하여 bean을 설정할 수 있다. 1234567891011&lt;!-- 빈 설정 --&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;bean id=\"service\" class=\"com.example.demo.Service\"&gt; &lt;property name=\"repository\" ref=\"repository\"/&gt;&lt;/bean&gt;&lt;bean id=\"repository\" class=\"com.example.demo.Repository\"&gt;&lt;/bean&gt;&lt;beans&gt; bean 태그로 빈을 설정할 수 있고 property태그로 내부의 객체를 주입할 수 있다. bean 태그를 통해 선언하는 방법은 다수의 빈을 추가하고자 할 때마다 xml 파일을 수정해야하는 번거로움이 있다. component scanner를 이용한 빈 설정 configuration 파일에 빈 스캐너를 선언하여 빈을 자동으로 등록할 수 있다. conponent-scan 태그를 사용하기 위해 beans 태그에 다음의 내용을 추가해주어야 한다. 1xmlns:context=\"http://www.springframework.org/schema/context\" context로 정의된 태그 component-scan을 beans태그 내부에 추가하여 빈 스캐너를 정의한다. 12&lt;!--빈 스캐너 --&gt;&lt;context:component-scan base-package=\"com.example.demo\"&gt;&lt;/context:component-scan&gt; 빈 스캐너는 @Service, @Repository와 같은 annotation이 설정된 객체를 찾아 컴포넌트로 등록한다. 12345678910111213@Repositorypublic class Repository{ }@Servicepublic class Service{ Repository repository; @autowired public void setRepository(Repository repository){ this.repository = repository; }}","link":"/2020/10/29/Spring/spring-1/"},{"title":"알고리즘 (2): 거품 정렬, 삽입 정렬, 선택 정렬, 합병 정렬, 빠른 정렬","text":"정렬 알고리즘 정렬 알고리즘은 원소들을 일정한 순서대로 열거하는 알고리즘이다. n개의 입력이 주어졌을 때 이를 효율적으로 정렬하는 것은 매우 중요하다. 정렬 알고리즘은 크게 수행시간(time complexity), 추가 공간의 필요성(in-place), 중복된 값에 대한 처리유무(stability)로 비교할 수 있다. 이 글에서의 정렬 알고리즘은 주어진 입력이 int형의 배열이라고 가정하고 설명함. 거품 정렬(Bubble Sort) 인접한 두 원소의 관계를 검사하여 정렬하는 알고리즘. 거품 정렬은 코드가 단순하며 이미 정렬된 입력에 대해 가장 빠르게 수행된다. 1234567891011void bubbleSort(int n, int* array){ for(int i=0;i&lt;n-1;i++){ for(int j=i+1;j&lt;n;j++){ if(array[j]&lt;array[i]){ int temp = array[i]; array[i] = array[j]; array[j] = temp; } } }} 삽입 정렬(Insertion Sort) 모든 원소를 이미 정렬된 부분과 비교하여 위치를 찾아 삽입하는 알고리즘. 첫 원소를 정렬된 상태라고 가정하고 두번째 원소의 삽입부터 삽입된 배열과 대소관계를 검사하여 원소의 위치를 결정한다. 거품 정렬에 비해 대입연산의 일부분을 외부 루프에서 수행하므로 수행시간이 빠르지만 최악의 경우 삽입되는 모든 $O(n^2)$의 시간복잡도를 갖는다. 1234567891011void insertionSort(int n,int* array){ for(int i=1;i&lt;n;i++){ int x = array[i]; int j = i-1; while(j&gt;=0 &amp;&amp; array[j]&gt;x){ array[j+1] = array[j]; j--; } array[j+1] = x; }} 선택 정렬(Selection Sort) 정렬되지 않은 모든 원소 중 최소 값을 선택하여 정렬하는 알고리즘. 선택 정렬은 내부 루프에서 대입연산을 수행하지 않아 대입 연산의 수행시간은 $3n$으로 최악의 경우에도 빠른 수행시간을 갖는다. 선택 정렬은 대소관계에 만족하는 경우 대입 연산을 수행하지 않는 거품 정렬, 삽입 정렬에 비해 내부 루프를 모두 탐색하고 외부 루프에서 대입 연산을 수행하므로 평균 수행시간이 최악의 경우의 수행시간과 같다는 단점이 있다. 또한 최소값의 위치와 교환이 일어나는 인덱스의 값이 다른 원소와 중복된 값인 경우, 들어온 순서에 상관없이 정렬이 이루어진다는 단점이 있다.(Non-Stable) 1234567891011void selectionSort(int n,int* array){ for(int i=0;i&lt;n-1;i++){ int smallest = i; for(int j=i+1;j&lt;n;j++){ if(array[j]&lt;array[smallest]) smallest = j; } int temp = array[smallest]; array[smallest] =array[i]; array[i] = temp; }} 합병 정렬(Merge Sort) 문제를 해결하기 쉽도록 배열을 여러 개의 작은 배열로 나누고(divide) 나눈 배열을 각각 정렬한 후(Conquer) 정렬한 배열을 통합하는 분할정복(divide &amp; conquer)를 사용하는 알고리즘. 배열을 합치는 과정에서 분할되었던 두 배열의 원소의 대소관계를 비교하여 반환될 배열에 차례대로 삽입하여 정렬이 수행된다. 순서에 의한 정렬이 배열의 통합에서 수행되므로 재귀함수를 사용하여 구현할 수 있고 수행시간도 $O(nlog n)$으로 빠르다는 장점이 있다. 배열을 분할할때마다 분할된 배열을 저장하는 공간이 추가적으로 필요하여 $2n$의 공간 복잡도를 갖는다는 단점이 있다. (제자리정렬 알고리즘이 아니다.) 123456789101112131415161718192021222324252627282930313233343536373839void mergeSort(int n,int* array){ int h = n/2, m=n-h; int* U = new int[h]; int* V = new int[m]; if(n&gt;1){ for(int i=0;i&lt;n;i++){ if(i&lt;h){ U[i] = array[i]; }else{ V[i-h] = array[i]; } } mergeSort(h,U); mergeSort(m,V); merge(h,m,U,V,array); }}void merge(int h, int m, int* U, int* V, int* array){ int i=0,j=0,k=0; while(i&lt;h&amp;&amp;j&lt;m){ if(U[i]&lt;V[j]){ array[k] = U[i]; i++; }else{ array[k] = V[j]; j++; } k++; } if(i&gt;h){ for(;j&lt;m;j++){ array[i+j] = V[j]; } }else{ for(; i&lt;h;i++){ array[i+j] = U[i]; } }} 빠른 정렬(Quick Sort) 임의의 기준(pivot)을 정하고 기준을 중심으로 관계를 검사하여 교환하는 알고리즘. 빠른 정렬은 분할정복(divide &amp; conquer)의 방식을 사용하며 이에 분할교환정렬(Partition Exchange Sort)이라고도 한다. 기준 값과의 대소비교를 통해 기준 값보다 작은 값들의 집합과 큰 값들의 집합으로 분할하는 방식을 반복함으로써 정렬이 이루어진다. 분할정복 방식이면서 퀵 정렬과 달리 추가적인 공간을 사용하지 않고 정렬할 수 있으며 재귀함수로 순환이 시작되기 전에 대부분의 작업이 수행되어. 입력 값들을 절반으로 나누어 정렬함으로써 수행시간은 $O(n logn)$이지만 기준 값을 최솟값 혹은 최대값으로 설정할 경우 정렬결과가 한쪽으로 쏠려(Skewed) 최악의 경우 수행시간은 $O(n^2)$을 갖는다. 중복된 값의 입력에 대하여 추가적인 공간을 사용하는 경우, 입력 순서를 유지할 수 있지만(non In-place, Stable) 추가적인 공간을 사용하지 않는 경우, 입력 순서에 상관없이 교환이 발생하므로(In-place, nonStable) Stable과 In-place 중 우선적으로 필요한 것을 선택해야한다. 기준을 정하는 방법은 여러가지 방법이 있지만, 임의의 3개의 원소 중 중간값을 기준 값으로 설정하고 가장 큰 값을 기준 보다 뒤에 있도록 옮겨 최소 1개의 큰 값들의 집합을 갖도록 하는 중간값 분할(Median-of-Three Partitioning)이 제일 좋은 방법으로 알려져 있다. 12345678910111213141516171819202122232425262728//Median-3 퀵 정렬 알고리즘void quickSort(int * array, int start, int end){ int pivot,m,l,r; if(end-start&gt;1){ l = start; r = end-1; m = (start+end)/2; if(array[start]&gt;array[m]) swap(array,start,m); if(array[start]&gt;array[end]) swap(array,start,end); if(array[m]&gt;array[end]) swap(array,m,end); swap(array,m,r); pivot = array[r]; for(;;){ while(array[++l]&lt;pivot); while(array[--r]&gt;pivot); if(l&gt;=r) break; swap(array,l,r); } swap(array,l,end-1); quickSort(array,start,l-1); quickSort(array,l+1,end); }else if(array[start]&gt;array[end]) swap(array,start,end);}void swap(int* array,int a, int b){ int temp = array[a]; array[a] = array[b]; array[b] = temp;}","link":"/2020/04/21/major/Algorithm/Algorithm-2/"},{"title":"알고리즘 (3): 쉘 정렬, 힙 정렬","text":"쉘 정렬 (Shell Sort) 멀리 떨어진 원소끼리 교환하여 정렬 속도를 향상시키는 정렬 알고리즘 삽입 정렬을 변형하여 병렬 처리로서 정렬을 수행한다. 교환할 원소들의 Gap을 서서히 줄여가면서 최종적으로 i번째 인덱스와 i+1번째 인덱스의 교환들로 정렬이 마무리된다. 최대 Gap의 크기를 어떻게 설정하는 가, gap이 1까지 줄어드는 과정에 따라 수행시간이 변화한다. 최대 gap의 크기는 2~3개의 원소를 비교하도록 설정하고 비교한 결과단위를 합쳐서 다시 검사하는 Divide &amp; Conquer 방식을 사용한다면 비교회수는 $N^{1.5}$를 넘지 않아 빠른 수행시간을 갖는다는 장점이 있다. 1234567891011121314151617181920212223//shellsort 알고리즘void shellsort(int n,int *array){ int h,v,i,j; //병렬처리의 수를 최대로 할 수 있는 gap찾기 //2~3개의 원소씩 병렬처리할 gap을 찾아 효율을 높일 수 있다. for(h=1; h&lt;n;h=3*h+1); //높은 gap에서부터 병렬처리후 낮은 gap의 병렬처리로 이동 for(;h&gt;0;h=h/3){ //gap만큼 떨어진 원소끼리 삽입정렬 // i를 h+1부터 n까지로 설정한 이유는 그 이하의 인덱스를 gap만큼 빼면서 검사하기때문. for(i=h+1;i&lt;=n;i++){ v=array[i]; //shellsort는 삽입정렬을 병렬처리한것. j=i; //비교 과정에서 삽입정렬과 쉘정렬의 차이는 //비교할 원소의 인덱스 차이가 1이냐 그보다 많은가에 있다. while(j&gt;h &amp;&amp; array[j-h]&gt;v){ array[j] = array[j-h]; j=j-h; } array[j] = v; } }} 힙 정렬(HeapSort) 힙을 이용해 정렬하는 알고리즘 힙은 자식과 부모간의 대소관계 규칙을 갖는 우선 순위 큐(Priority Queue)의 일종 루트 노드는 오름차순/내림차순 정렬의 최우선 값을 갖는다. 루트 노드를 가져오고 삭제하면서 자식 노드들 중 최대/최소 값을 계산하여 루트노드로 변경하는 작업을 통해 힙의 규칙을 유지 리스트의 수만큼 루트노드를 꺼내어 순서대로 리스트를 형성하면 정렬된 리스트를 얻을 수 있음 힙은 부모-자식간의 규칙이 있지만 같은 깊이의 노드들에 대해 규칙이 존재하지 않는다. 따라서 같은 값에 대해 입력순서가 지켜지지 않아 불안정적이다. 같은 깊이의 노드들은 $2^{깊이}$ 만큼의 노드를 가질 수 있다. 정렬시 자식과의 비교만이 이루어지므로 N개의 원소의 정렬에 대하여 $N \\log{N}$의 수행시간을 갖는다. 1234567891011121314151617181920212223242526272829303132//힙정렬 알고리즘void inplaceHeap(int* arr,int length){ //배열은 1~(length)까지있음 //heapify (leaf노드들은 어짜피 자식 노드가 없으므로 leaf의 부모 노드들부터 자식노드들과 비교) for(int i=length/2; i&gt;=1;i--){ heapify(arr,i,length); } //힙으로 만든 배열을 오름차순으로 배열화 for(int i=length-1;i&gt;=1;i--){ //swap으로 보낸 root는 건들지 않는다. //마지막 원소를 root와 swap하는것으로 오름차순으로 맨 뒤에서부터 fix한다. int temp = arr[1]; arr[1] = arr[i+1]; arr[i+1] = temp; heapify(arr,1,i); }}//heapify-현재 값을 자식 노드들과 비교하며 swap한다.void heapify(int* arr, int h, int m){ int v = arr[h]; int j =2*h;//leftchild의 위치를 찾는다. for(; j&lt;=m;j=2*j){ //child로 내려가면서 값을 비교한다. if(j&lt;m &amp;&amp; arr[j]&gt;arr[j+1]) j=j+1; //leftchild rightchild 비교해서 더 작은 값과 비교 if(v&lt;=arr[j]) break; //상위 값이 자식값보다 크다면 더이상 볼필요없음 else arr[j/2] = arr[j]; //부모노드로 이동 } arr[j/2] = v;}","link":"/2020/07/09/major/Algorithm/Algorithm-3/"},{"title":"알고리즘 (4): 트리","text":"트리 정보를 갖는 노드들의 집합 수직 계층의 자료구조로, 하나의 루트 노드로부터 연결된 여러 노드들은 부모 자식의 관계를 가지며 자기 자신이 부모 노드가 되어 다른 노드를 자식으로서 연결할 수 있다. 루트(Root): 부모를 갖지 않는 최상단 노드 자식(Child): 부모 노드에 연결된 노드, 해당 노드에 접근하기 위해서는 부모 노드를 통해 접근해야 한다. 형제(Siblings): 같은 부모에 연결된 노드들은 형제 관계를 갖지만 트리 특성상 형제 노드만으로는 접근이 불가능하고 부모노드를 통해서만 접근 가능하다. 내부 노드(Internal node): 최소 하나의 자식을 갖는 노드 외부 노드(External node, Leaf node): 자식을 갖지 않는 노드 조상 노드(ancestor node): 노드의 부모 노드가 루트가 아니라면 해당 부모 노드도 부모 노드를 갖는다. 부모 노드 또한 조상 노드로서 표현됨. 깊이(Depth): 루트 노드로부터 자신까지 가는 경로의 길이. 레벨(Level): 루트 노드에서 자신까지 가는 경로+1. 높이(Height): 트리가 갖는 노드들의 최대 깊이를 의미. 차수(Degree): 자식노드가 최대로 가질 수 있는 형제 노드의 수 이진트리(Binary Tree) 자식노드가 최대 두개인 노드들로 구성된 트리 내부 노드의 자식들을 좌측 자식, 우측 자식으로 나누어 표현한다. 정 이진 트리(full binary tree): 모든 내부 노드들이 자식을 두 개 갖는 이진 트리 완전 이진 트리(complete binary tree): 마지막 레벨을 제외하고 모든 레벨에 노드들이 완전히 채워져 있고 외부 노드의 경우 왼쪽부터 채워진 트리 균형 이진 트리(balanced binary tree): 모든 외부노드들이 같은 깊이를 갖거나, 깊이의 차이가 최대 1인 트리 트리 순회전위 순회(Preorder Traversal) 자식 노드에 접근하기 전에 노드를 방문하는 순회 방식 자식 노드의 접근은 자식간의 관계에 의해 형성된 순서를 지키며 먼저 방문함12345void preOrder(node* v){ visit(v); preOrder(v-&gt;left); preOrder(v-&gt;right);} 후위 순회(Postorder Traversal) 자식 노드에 먼저 접근한 후 자신의 노드를 방문하는 순회방식 루트 노드는 최상위 노드이므로 후위 순회에서 가장 마지막에 방문되어진다.12345void postOrder(node* v){ postOrder(v-&gt;left); postOrder(v-&gt;right); visit(v);} 중위 순회 좌측 자식 -&gt; 현재 노드 -&gt; 우측 자식의 순으로 노드를 방문하는 순회방식 자식 사이에 현재 노드의 방문이 이루어지므로 이진트리가 아닌 경우 임의로 순서를 정하여 순회할 수 있다.12345void inOrder(node* v){ inOrder(v-&gt;left); visit(v); inOrder(v-&gt;right);} 오일러 투어 순회(Euler Tour Traversal) 현재 노드 -&gt; 좌측 자식 -&gt; 현재 노드 -&gt; 우측 자식 -&gt; 현재 노드의 순으로 노드를 방문하는 순회방식 현재 노드를 먼저 방문하는 전위 순회, 좌측 자식 방문 후 자기 노드를 방문하고 우측 노드를 방문하는 중위 순회, 자식 노드를 방문한 후 자기 노드를 방문하는 후위 순회가 모두 합쳐진 순회방식으로 볼 수 있다.1234567891011void eulerTour(node* v){ visit(v); if(v-&gt;left != nullptr){ eulerTour(v-&gt;left); visit(v); } if(v-&gt;right != nullptr){ eulerTour(v-&gt;right); visit(v); }}","link":"/2020/08/11/major/Algorithm/Algorithm-4/"},{"title":"알고리즘 (1): 알고리즘 분석과 복잡도","text":"알고리즘특정 문제를 해결하기 위해 기술하는 명령문 알고리즘의 요건1. 완전성과 명확성 수행결과의 순서가 완전하고 명확하게 명세되어야 한다. 알고리즘이 지시하는대로 실행하면 의도한 결과가 얻어져야 한다. 2. 입력과 출력 입력: 알고리즘이 처리해야 할 대상, 제공되는 데이터 출력: 입력 데이터를 처리하여 얻은 결과 3. 유한성 단계는 유한해야하며 마지막 단계는 종료여야 한다. ADL(Algorithm Description Language) 알고리즘 기술을 위해 정의한 언어 의사코드(pseudo-code): ADL과 자연어로 기술한 코드 ADL알고리즘은 ADL변환기를 통해 각 언어의 프로그램으로 변환한다. ADL의 명령문의 끝에는 세미콜론(;)을 사용해야 한다. 알고리즘의 평가 기준공간 복잡도 알고리즘을 실행하여 완료하는데 필요한 총 저장 공간 가변 공간 런타임 스택을 위한 저장 공간(가변 데이터와 변수들이 필요로 하는 공간) 공간 복잡도에서 가변 공간만을 고려한다. 시간 복잡도 알고리즘을 실행시켜 완료하는데 소요되는 시간 실행 시간 단위 명령문 하나를 실행하는데 소요되는 시간 시작 복잡도에서 컴파일 시간은 생각하지 않고 실행 시간만을 고려한다. 복잡도 분석점근적 분석(Asymptotic Analysis) 변수의 개수 N이 증가할 때마다 실행시간이 점근적으로 증가한다 는 사실에 의한 분석법 알고리즘의 worst-case의 dominant factor가 알고리즘의 시간 복잡도를 결정한다. (실제 실행시간은 c*f(n)) 대표적인 복잡도 카테고리 $\\theta (1)$: constant complexity, 입력 데이터 수에 무관하다.(ex 해쉬) $\\theta (log n)$: logarithmic complexity, 대체적으로 divde &amp; conquer로 이루어짐.(ex 이진검색) $\\theta (n)$: linear complexity, (ex 검색) $\\theta (n^{2})$: quadratic complexity(ex 이중 루프 삽입정렬, 선택정렬) $\\theta (n^{3})$: cubic complexity(ex 삼중 루프, 행렬의 곱셈) $\\theta (2^{n})$: exponential complexity, 시간복잡도가 거의 무한하다고 볼 수 있다.(ex Knapsack problem, Fibonacci, Hanoi) $\\theta (n^3)$ 이상의 시간복잡도를 가진 알고리즘은 좋지 않은 알고리즘이다. Big O 표기법 점근적 상한(Asymptotic Tight Upper Bound)로 시간 복잡도를 파악한다 주어진 복잡도 f(n)에 대해서 g(n) $\\in$ O(f(n))이면 g(n)을 f(n)의 Big O라고 한다. $n \\geq N$인 모든 정수 n에 대해 $g(n) \\leq c \\times f(n)$이 성립하는 실수 c&gt;0과 음이 아닌 입력의 크기 N이 존재 알고리즘의 시간 복잡도가 O(f(n))이라면 이 알고리즘의 수행시간은 아무리 늦어도 f(n)은 된다는 것을 뜻함(f(n)이 상한) 최악의 경우 이정도 시간이면 된다라는 것을 뜻함 Big O 찾기 점화식을 통해 g(n)을 찾는다. $T_n \\geq cf(n)$ c, N을 임의로 선택한다. n&gt;N임을 증명한다. (cf(n)이 항상 g(n)보다 크거나 같은지 확인한다.) 가급적이면 N=0이 성립하는 c를 찾는 것이 중요하다 Omega 표기법 점근적 하한(Asymptotic Tight Lower Bound)로 시간 복잡도를 파악한다. 주어진 복잡도 f(n)에 대해서 g(n) $\\in \\Omega$(f(n))이면 g(n)을 f(n)의 Omega라고 한다. $n \\geq N$인 모든 정수 n에 대해 $g(n) \\geq c \\times f(n)$이 성립하는 실수 c&gt;0와 음이 아닌 입력의 크기 N이 존재 알고리즘의 시간 복잡도가 $\\Omega$(f(n))이라면 이 알고리즘의 수행시간은 아무리 빨라도 f(n)밖에 되지 않음을 뜻함(f(n)이 하한) 최소한 이정도 시간이 걸린다는 것을 뜻함 모든 정렬 알고리즘은 $\\Omega$(N)이다. N개의 데이터를 정렬하는데 N개 데이터를 모두 읽지 않고 정렬 할 수는 없기 때문이다. Omega 찾기 (모순 유도에 의한 증명) $\\Omega$(f(n))을 임의로 가정한다. $n \\geq N$인 모든 정수 n에 대해서 c&gt;0, 음이 아닌 정수 N이 존재함을 확인한다. Big Theta 표기법 Asymptotic Tight Bound로 시간 복잡도를 파악한다. 주어진 복잡도 f(n)에 대해서 g(n) $\\in \\Theta$(f(n))이면 g(n)은 f(n)의 차수(Order)라고 한다. $c \\times f(n) \\geq g(n) \\geq d \\times f(n)$이 성립하는 실수 c&gt;0과 d&gt;0, 그리고 음이 아닌 입력의 크기 N이 존재 알고리즘의 시간 복잡도가 $\\Theta$(f(n))이라는 것은 상한과 하한이 마주침으로서 더 이상 좋은 알고리즘이 존재하지 않음을 뜻함 Little-O 표기법 여유있는 상한(loose upper bound)를 나타낸다. 충분히 큰 n($n-&gt;\\infty$)에 대해 g(n)이 큰 모든 함수의 집합 Little-$\\omega$표기법 여유있는 하한(loose lower bound)를 나타낸다. 충분히 큰 n($n-&gt;\\infty$)에 대해 f(n)이 큰 모든 함수의 집합 순환(recursion) 정의하려는 개념 자체를 정의 속에 포함 종류 직접 순환: 함수가 직접 자신을 호출 간접 순환: 다른 함수를 호출하고 그 함수가 다시 자신을 호출 순환 방식의 적용 분할 정복(divide and conquer)의 특성을 가진 문제에 적합 복잡한 문제를 직접 간단하게 풀 수 있는 작은 문제로 분할하여 해결하는 방법 순환 알고리즘의 시간 복잡도 분석 첫 순환으로부터 점화식을 구한다. 순환이 정지할 때까지의 시간 복잡도를 구한다. 입력의 크기 n에 대한 총 순환 수 i를 구해 점화식을 일반화한다. 마스터 정리(Master Theorem) $T_n = aT(\\frac{n}{b})+f(n)$, $n^{\\log_{b}{a}}=h(n)$에 대해 h(n)과 f(n)의 무게를 비교하여 수행시간을 바로 분석할 수 있음 어떤 양의 상수 $\\epsilon$에 대하여 $\\frac{f(n)}{h(n)}=O(\\frac{1}{n^{\\epsilon}})$이면 $T(n) = \\Theta (h(n))$이다. (h(n)이 수행시간을 결정) 어떤 양의 상수 $\\epsilon$에 대하여 $\\frac{f(n)}{h(n)}= \\Omega (n^{\\epsilon})$이고 c&lt;1인 모든 상수 c와 모든 n에 대해 $af(\\frac{n}{b}) \\leq cf(n)$이면 $T(n)=\\Theta (f(n))$이다. (f(n)이 수행시간을 결정) $\\frac{f(n)}{h(n)}= \\Theta (1)$이면 $T(n) = \\Theta (\\frac{f(n)}{log n})$이다. *(f(n)log n이 수행시간이 된다.) 단, f(n)과 g(n)이 log를 갖는 경우, log를 무시하여 비교한다.","link":"/2020/04/20/major/Algorithm/Algorithm-1/"},{"title":"Ch 1. OSI와 인터네트워킹 장비(1) - OSI","text":"Internetworking Architure 개별 네트워크들의 내적 일관성을 유지한다. 인터넷에 접속하기 위해 개별 네트워크의 변경이 불필요하다. 패킷 오류 발생시 소스로부터 재전송한다. (Stupid Network) 게이트웨이 또는 라우터라 불리는 블랙박스를 이용해 네트워크들을 연결한다. 운용 측면에서 볼 때 전체적인 통제(global control)는 불필요하다. OSI 참조 모델1980년 말경에 개방형 시스템 간의 통신을 위해 제안된 네트워크 모델.프로토콜을 7계층으로 분류하여 규정한 규격을 가지며 각 계층은 하위 계층의 기능만을 이용하고 상위 계층에게 기능을 제공한다.일반적으로 하위 4계층은 하드웨어로, 상위 3계층은 소프트웨어로 구현된다. 1계층: 물리 계층 데이터를 물리 매체 상으로 전송하는 역할 물리적 링크의 설정, 유지, 해제 담당 전송 매체, 전송률, 신호의 인코딩 방식에 대한 특성을 정의 사용자 장비와 네트워크 종단 장비 간 물리적, 전기적 인터페이스 규정 전송선로의 종류에 따른 전송 방식과 인코딩 방식 결정 2계층: 데이터 링크 계층 물리 계층에서 전송하는 비트들에 대한 동기 및 식별 기능 전송 매체에 프레임을 송수신하는 역할을 담당 원활한 데이터의 전송을 위한 흐름제어(Flow Control) 기능 안전한 데이터 전송을 위한 오류 제어(Error Control) 기능 헤더(header)와 트레일러(trailer) 이용&nbsp;&nbsp;- 헤더필드에는 송신지와 수신지의 주소를 포함&nbsp;&nbsp;- 트레일러에는 오류 검출 코드를 포함 3계층: 네트워크 계층 송신 측과 수신 측간의 논리적 링크 설정 상위 계층 데이터를 패킷으로 분할 TCP/IP상에서 IP계층으로 불리며 다음과 같은 프로토콜이 존재&nbsp;&nbsp;- IP: 호스트 네트워크 주소 관리, 패킷을 라우팅하는 역할&nbsp;&nbsp;- ARP(Address Resolution Protocol): 네트워크 호스트들의 하드웨어 주소를 얻는데 사용&nbsp;&nbsp;- ICMP(Internet Control Message Protocol): 패킷 전송에 관한 오류 메시지 처리 4계층: 전송 계층 네트워크 서비스와 상위 사용자 서비스를 구분 전체 메시지의 종단간(end-to-end) 전달&nbsp;&nbsp;- TCP: 데이터의 확실한 전송이 필요한 경우 사용&nbsp;&nbsp;- UDP: 데이터의 정확한 전달을 보장하지 않음. 흐름 제어 및 오류 제어 기능 전송 계층은 네트워크에 관여하지 않음 5계층: 세션 계층 송수신 프로세스 사이의 세션의 확립 및 유지, 종료 담당 반이중 대화(half duplex dialog), 전이중 대화(full duplex dialog)의 설정 및 동기화 유지 6계층: 표현 계층 전송 데이터의 구문과 의미에 대한 처리를 담당 통신을 위해 네트워크 표준 형식으로 데이터 변환 7계층: 응용 계층 응용 프로그램이 네트워크에 접근 가능하도록 인터페이스 기능을 수행 email, http 등을 정의하는 계층 TCP/IP 모델에서 5,6,7계층을 묶어 응용 계층으로 통합하기도 한다. 캡슐화네트워크의 통신은 물리 계층을 통해서 이루어지며 상위 계층의 데이터를 전송하고자 할 때 데이터에 헤더를 추가하여 하위계층으로 보낸다.이를 캡슐화(encapsulation)이라 한다.통신을 통해 받은 데이터는 헤더를 읽어 내부 데이터의 종류를 파악하고 이를 수신측의 각 계층에 전달한다. 계층간의 통신상위 계층은 하위 계층에게 순수 데이터 뿐 아니라 수신측의 계층에서 데이터를 이해할 수 있는 정보, 받은 데이터를 컨트롤할 수 있는 파라미터를 보낸다. SDU(Service Data Unit): N+1계층에 의해서 N계층과 N-1계층으로 투명하게 전달되는 사용자 데이터 PCI(Protocol Control Information): 네트워크의 다른 동등 계층으로 보내지는 정보이며 동등 계층에게 어떤 기능을 수행하도록 지시하는 헤더 PDU(Protocol Data Unit): SDU와 PCI의 결합체 ICI(Interface Control Unit): 서비스를 호출하기 위해서 N과 N-1계층 사이에서 전달되는 임시 파라미터 IDU(Interface Data Unit): 계층 경계를 통과하여 전달되는 전체 정보 N+1 계층의 IDU는 N계층에서 SDU가 되며 N계층의 SDU와 PCI가 결합하여 PDU가 된다.N계층의 PDU는 ICI와 결합하여 IDU로서 N-1계층에 전달되어진다. 출처: 정진욱, 김현철 공저. “TCP/IP와 인터넷”, pp 17-21. 2004. (주)생능출판사","link":"/2020/04/19/major/Internet%20Protocols/InternetProtocols-1/"},{"title":"Ch 5. 윈도우 네트워크 프로그래밍(1) - 윈도우 소켓과 관련 함수","text":"윈도우 네트워크 프로그래밍클라이언트 - 서버 모델 서버와 클라이언트는 단일 프로그램으로 작동 서버는 클라이언트의 연결요청을 대기, 클라이언트에게 정보 및 서비스를 제공 클라이언트는 서버에게 정보 및 서비스를 요청하고 응답을 기다림 ex) 웹 사이트는 아파치와 같은 웹 서버가 서버 역할을 수행, 사용자가 사용하는 웹 브라우저(크롬, 엣지)는 클라이언트의 역할을 수행 클라이언트는 서버와 동일한 컴퓨터에서 다른 프로세스로 존재할 수 있고 다른 컴퓨터에서 연결된 네트워크로 존재할 수 있음 네트워크 프로그래밍 원 거리 사용자간의 원활하고 빠른 의사 소통을 위해 활용 네트워크로 연결되어 있는 두 호스트 간의 데이터 송/수신이 이루어짐 파일 입/출력과의 차이점은 소켓(socket)을 사용한 프로그래밍 방식 소켓(socket) 네트워크를 통한 입/출력을 위해 사용자에게 필요한 수단을 제공하는 응용 프로토콜 인터페이스 네트워크를 경유하는 프로세스 통신의 종착점 전송 계층(4계층)과 응용 계층(5계층) 사이의 인터페이스로서 응용 프로그램으로부터 데이터를 목적지 프로세스까지 캡슐화하여 전달하는 역할을 수행 소켓을 활용한 네트워크 응용 프로그램을 통해 네트워크 상에서 데이터를 송/수신 TCP/UDP 소켓 TCP: 연결형, 신뢰성 보장을 위해 포트의 연결이 필요, 클라이언트의 연결 요청과 서버의 연결이 수행됨 UDP: 사용자 데이터그램 프로토콜(User Datagram Protocol)의 약자, 데이터그램으로 알려진 단순 메시지를 교환하기 위해 사용, 서버와 클라이언트는 별도의 연결 수행 없이 데이터의 송/수신이 이루어짐 윈도우 소켓 프로그래밍윈도우 소켓(WinSock) BSD 계열 유닉스 소켓을 참고로 설계된 윈도우 기반 소켓, 리눅스 기반 소켓과 유사 윈속(윈도우 소켓)사용 방법 Winsock2.h 헤더 파일을 포함 Ws2_32.lib 라이브러리 링크 윈속 사용을 위한 라이브러리 초기화 및 해제 윈도우 소켓 초기화123456#include&lt;winsock2.h&gt;int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);//사용 예시WSADATA wsaData;if(WSAStartup(MAKEWORD(2,2),&amp;wsaData)!=0) ErrorHandling(\"WSAStartup() error!\"); 윈속 사용을 위한 라이브러리 초기화 wVersionRequested: 사용하고자 하는 윈속 버전을 명시 16비트의 unsigned short인 WORD로 버전을 입력받음 MAKEWORD(2,2)는 윈속 버전 2.2를 의미 lpWSAData: WSADATA 구조체 타입 변수 포인터 성공시 리턴 값 0, 실패시 에러코드값 반환 윈도우 소켓 해제1234#include&lt;winsock2.h&gt;int WSAClenaup(void);//사용 예시WSACleanup(); 소켓 연결이 종료되었을 경우 할당 받은 리소스를 해제하는 작업을 수행 윈속 해제 이후 관련 함수의 호출이 불가능해짐 성공시 리턴 값 0, 실패시 SOCKET_ERROR 소켓 주소 구조체기본형12345#include&lt;sys/socket.h&gt;struct sockaddr{ unsigned short sa_family; char sa_data[14];} sa_family: 주소 체계를 나타내는 변수 sa_data: 소켓의 주소를 나타내는 char배열, 포트 및 IP주소 정보가 담겨져 있음 AF 소켓 구조체1234567891011#include&lt;sys/socket.h&gt;struct in_addr{ unsigned long s_addr;}struct sockaddr_in{ short sin_family; short sin_port; struct in_addr sin_addr; char sin_zero[8];} sin_family: 주소 체계를 나타내는 변수, AF_INET/AF_UNIX/AF_NS 등의 주소 체계가 적용되며 TCP에서는 AF_INET체계를 사용 sin_port: 포트번호를 나타내는 16비트 변수 sin_addr: IP주소를 나타내는 32비트 변수 sin_zero: 소켓 구조체의 크기를 16바이트로 맞추기 위해 0으로 채우는 목적의 변수 소켓 생성12345#include&lt;winsock2.h&gt;SOCKET socket (int af, int type, int protocol);//사용 예시SOCKET hServSock;hServSock = socket(PF_INET,SOCK_STREAM,0); 소켓을 생성하여 통신을 위한 end-point를 정의 af: 소켓에 사용되는 프로토콜 패밀리 PF_INET: IPv4 인터넷 프로토콜 PF_INET6: IPv6 인터넷 프로토콜 PF_LOCAL: 로컬 통신을 위한 UNIX 프로토콜 PF_PACKET: Low Level socket을 위한 인터페이스 PF_IPX: IPX 노벨 프로토콜 type: 소켓의 유형 SOCK_STREAM: 스트림 방식의 연결형 서비스 소켓 생성, 전달된 순서대로 수신, 전송된 모든 데이터는 에러 없이 원격지에 도달 SOCK_DGRAM: 데이터그램 방식의 비연결형 서비스 소켓 생성 protocol: 소켓에 사용되는 프로토콜 (대부분의 응용프로그램에서 0) socket함수는 소켓 번호를 리턴 소켓 주소 할당12345678910#include&lt;winsock2.h&gt;int bind(SOCKET s, const struct sockaddr* name, int namelen);//사용 예시SOCKADDR_IN servAddr;ZeroMemory(&amp;servaddr,sizeof(servaddr));servaddr.sin_family=AF_INET;servaddr.sin_port=htons(13451);servaddr.sin_addr.s_addr=htonl(INADDR_ANY);if(bind(hServSock,(SOCKADDR*)&amp;servAddr, sizeof(servAddr))==SOCKET_ERROR) ErrorHandling(\"bind error\"); 소켓에 IP주소와 포트번호를 할당 서버 프로그램에서 사용, 소켓에 포트번호와 주소를 명시하여 클라이언트가 해당 소켓에 접근할 수 있도록 함 name: 소켓에 할당하려는 소켓 구조체 정보 SOCKADDR 기본형은 sa_data 배열에 포트 및 IP주소를 모두 명시해야함 SOCKADDR_IN형의 객체에 포트번호와 주소를 명시하고 SOCKADDR형으로 캐스팅하여 사용함으로서 가독성을 높일 수 있음 namelen: 소켓 구조체 크기 성공시 리턴 값 0, 실패시 SOCKET_ERROR(-1) 소켓 연결대기12345#include&lt;winsock2.h&gt;int listen(SOCKET s,int backlog);//사용 예시if(listen(hServSock,5)==SOCKET_ERROR) ErrorHandling(\"listen error\"); 서버는 클라이언트로부터 연결 요청을 기다리기 위해 포트를 열어두어야함 backlog: 접속 요청을 동시에 받아들일 수 있는 큐의 크기 listen상태의 소켓은 여러 클라이언트로부터 연결 요청을 받을 수 있음 성공시 리턴 값 0, 실패시 SOCKET_ERROR(-1) 소켓 연결12345#include&lt;winsock2.h&gt;int connect(SOCKET s, const struct sockaddr *name, int namelen);//사용 예시if(connect(hSocket,(SOCKADDR*)&amp;servAddr,sizeof(servAddr))==SOCKET_ERROR) ErrorHandling(\"connect error\"); 클라이언트에서 사용하는 함수로 listen상태의 서버 소켓에 연결을 요청 클라이언트는 미리 알아둔 서버의 IP주소 및 포트번호가 포함되어 있는 소켓 구조체를 생성하여 함수에 사용 성공시 리턴 값 0, 실패시 SOCKET_ERROR(-1) 소켓 연결 수락1234#include&lt;winsock2.h&gt;SOCKET accept(SOCKET s,struct sockaddr *addr,int* addrlen);//사용 예시SOCKET hCliSock = accept(hServSock,(SOCKADDR*)&amp;cliAddr,&amp;szCliAddr); 서버에서 사용하는 함수, 클라이언트로부터 연결 요청을 받은 listen 상태의 소켓은 해당 클라이언트와의 연결을 담당하는 새로운 소켓을 생성 기존 listen 상태의 소켓은 다른 클라이언트로부터의 연결 요청을 대기함 성공시 리턴 값은 생성된 소켓 번호, 실패시 SOCKET_ERROR(-1) 데이터 송/수신12345678#include&lt;winsock2.h&gt;int send(SOCKET s,const char* buf, int len, int flags);int recv(SOCKET s,char *buf, int len, int flags);//사용 예시char msg[] = \"msg\"send(hCliSock,msg,suzeof(msg),0);int strlen = recv(hCliSock,msg,sizeof(msg)-1,0); 데이터를 송/수신하는 함수 recv함수의 len은 수신할 수 있는 최대 바이트 수 데이터 수신시 len을 sizeof(msg)-1로 하는 이유는 배열이 0부터 시작하기 때문. 성공시 리턴값은 송/수신된 바이트 수, 실패시 SOCKET_ERROR(-1) 소켓 종료12345#include&lt;winsock2.h&gt;int closesocket(SOCKET s);//사용 예시closesocket(hCliSock);closesocket(hServSock); 소켓을 종료하는 함수 생성된 소켓은 반드시 프로그램 종료 전에 소켓을 종료해야함","link":"/2020/07/04/major/Internet%20Protocols/InternetProtocols-10/"},{"title":"Ch 1. OSI와 인터네트워킹 장비(2) - 인터네트워킹 장비","text":"인터네트워킹 장비리피터(Repeater) OSI 참조 모델의 물리계층에서 동작하는 장비 전기나 광 신호를 증폭하는 기능을 수행&nbsp;&nbsp;- 매체를 통해 전달되는 신호는 감쇄(auttenuation)가 발생한다. 오류 신호도 같이 증폭한다는 단점이 존재함 리피터에 의해 연결된 네트워크는 완전히 하나의 네트워크로 동작한다. 전송거리에 의한 전송지연의 영향을 받기 쉬워 연결에 제한이 존재한다. 허브(Hub) 가까운 거리의 컴퓨터들을 UTP(Unshielded Twisted Pair)케이블을 사용하여 상호 연결하는 장비이며 신호를 증폭하는 리피터의 역할, 깨끗한 펄스를 만드는 역할도 수행한다. 허브의 종류에는 더미 허브, 인텔리전트 허브, 그리고 스택커블 허브가 있다.&nbsp;1. 더미 허브: 호스트 간을 연결시켜 주는 일반적인 기능을 수행하며 단순히 수신한 데이터를 허브의 다른 모든 포트로 전달한다.&nbsp;2. 인텔리전트 허브: 더미 허브의 기능에 네트워크 관리 기능을 추가한 허브를 말한다.(문제가 발생한 PC를 찾아내어 자동으로 도메인에서 제외)&nbsp;3. 스택커블 허브: 캐스케이드(cascade) 케이블을 이용하여 여러 대의 허브를 하나로 묶을 수 있다. 브리지(Bridge) 브리지는 OSI 데이터링크 계층에서 동작하는 네트워크 장비이다. 한 포트에서 수신한 모든 프레임을 일단 버퍼에 저장하고 오류가 발생하지 않은 프레임만을 선택하여 목적지로 전달한다. 다른 포트를 목적지로 하는 프레임만을 전달하고 동일한 포트 내에서 송수신되는 프레임은 다른 포트로 전달하지 않는다. Self Learning 기능을 통해 Table을 작성하고 변경하여 브리지를 기준으로 포트를 분리(Segment)하여 쓸데없는 트래픽을 줄인다. 브리징 알고리즘에 따라 투명 브리지와 소스 루트 브리지로 나뉜다.&nbsp;1. 투명 브리지(Transparent Bridge): 수신된 프레임은 일단 버퍼에 저장되고 프레임의 목적지 필드에 따라 FDB(Forwarding Data Base)를 참조하여 전달경로를 결정한다. FDB에 존재하지 않으면 프레임을 수신한 포트를 제외한 나머지 포트로 프레임을 전송한다.&nbsp;2. 소스 루트 브리지(Source Route Bridge): 경로 탐색 프레임을 사용하여 목적지까지의 경로를 발견한다. 경로 탐색 프레임을 수신한 목적지 포트는 적절한 경로를 송신 포트에 알려줌으로서 경로를 탐색한다. 스위치(switch) 고속으로 프레임을 전달하기 위해 개발됨. 초기 스위치는 데이터링크 계층의 주소를 이용해 동작하므로 L2스위치 또는 이더넷 스위치라고도 불리며, 브리지처럼 여러 네트워크 간의 고속 스위칭 서비스를 제공함. 스위치는 동작 방식에 따라 Cut-Through, Interim Cut-Through, Store-And Forward 스위칭 방식으로 구분된다. 1.Cut-Through 방식 프레임의 송신지 및 수신지 주소를 얻기 위해 프레임의 처음 몇 바이트만을 검색한다. 프레임의 오류검사 없이 목적지 포트로 전달함으로써 프레임의 대기시간과 전달 시간을 최소화한다. Cut-Through 스위치는 Store-and Forward 방식에 비해 대기시간이 1/20 밖에 되지 않음. 프레임의 최소 규격(64바이트)보다 작은 런트(runt) 프레임과 오류가 발생한 프레임을 검출할 수 없다. 2.Interim Cut-Through 방식 Cut-Through방식에서 런트 프레임의 중계를 막는 기능을 추가한 스위치 프레임의 길이가 64바이트 이하인 경우에는 프레임을 삭제한다. 3.Store-and-Forward 방식 오류가 없는 프레임만을 저장, 전달하는 방식 프레임 대기시간이 길어진다는 단점이 있음. 라우터(Router) 네트워크 계층 장비 하나의 네트워크를 여러 개의 세그먼트로 분리하기 위해 방송 트래픽 차단 기능을 수행함. 패킷의 IP주소를 기반으로 최적의 경로를 선택하여 인접 라우터로 패킷을 전달함. 라우팅 테이블을 관리하며 목적지 주소를 테이블에서 발견할 수 없다면 디폴트 라우터로 전송한다. 송신측과 수신측 호스트가 서로 다른 네트워크 프로토콜을 사용하는 경우, 다중 프로토콜 라우터를 이용하여 연동할 수 있음. (Gateway의 역할을 한다.) 게이트웨이(GateWay) 서로 다른 프로토콜을 사용하는 네트워크의 연동을 위해 프로토콜을 변환해주는 네트워크 장비 OSI 참조 모델의 모든 계층에 대해서 동작한다. 여러 단계의 네트워크 변환기능을 수행하므로 네트워크 병목 현상의 원인이 될 수 있다. 출처: 정진욱, 김현철 공저. “TCP/IP와 인터넷”, pp 22-32. 2004. (주)생능출판사","link":"/2020/04/20/major/Internet%20Protocols/InternetProtocols-2/"},{"title":"Ch 2. IPv4(3) - IP주소 관련 프로토콜","text":"IP주소 관련 프로토콜 논리적인 차원의 데이터 전송은 IP주소를 통해 이루어지지만 실제 물리 계층에서의 전송은 물리 계층 주소를 통해서 이루어진다. 논리 주소(IP address)와 물리 주소(MAC address) 사이의 변환 프로토콜이 필요. ARP(Address Resolution Protocol) 동일 네트워크에 존재하는 호스트에 대해 목적지의 IP주소에 해당하는 물리 주소를 찾는 프로토콜. ARP 메시지 ARP 요청 메시지 (ARP Request) - 특정 IP 주소에 대한 물리 주소를 요구, 호스트는 ARP 요청 메시지를 보낼 때 수신측 물리 주소를 모르기 때문에 물리 계층 브로드캐스트로 전송 ARP 응답 메시지 (ARP Response) - 물리 주소 정보를 알림, ARP 요청 메시지를 수신한 호스트/라우터는 자신의 물리 주소를 요구하는 경우 ARP 응답 메시지 전송. 특정 주소에게서 물리 주소를 받기 위해 호스트는 브로드캐스트로 ARP 요청 메시지를 전송하며, 이를 수신한 호스트는 자신의 IP주소와 같을 때, 자신의 물리 주소가 담긴 ARP 응답 메시지를 전송한다. 다른 서브넷에 위치하는 호스트의 MAC주소를 요청하는 경우, 라우터가 자신의 MAC 주소를 응답하여 라우터에서 데이터를 대신하여 받고 호스트에게 데이터를 전송한다(Proxy ARP). ARP 패킷 하드웨어 타입 - 하드웨어 인터페이스 종류를 정의하는 부분, 이더넷에 대한 값은 1이다. 프로토콜 타입 - 상위 계층 프로토콜을 정의, IPv4의 경우 0x0800 하드웨어 길이 - 물리 주소의 길이, 이더넷은 6(bytes) 프로토콜 길이 - 논리 주소의 길이, IPv4는 4(bytes) 동작 모드(Operation) - ARP 요청은 1, ARP 응답은 2 송신측 하드웨어 주소 - 송신측 MAC주소 송신측 프로토콜 주소 - 송신측 IP주소 수신측 하드웨어 주소 - 수신측 MAC주소, ARP 요청 메시지는 0으로 설정된다. 수신측 프로토콜 주소 - 수신측 IP주소 ARP 캐시 (Cache) 동일한 호스트에 대해 패킷을 보낼 때 마다 물리 주소를 찾는 것은 비효율적이므로 캐시를 생성하여 IP 주소와 물리 주소 간의 바인딩을 유지한다. 일정 시간동안 사용되지 않은 엔트리는 자동으로 삭제됨. 그래튜퍼스(gratuitous) ARP 새로운 LAN카드 설치나 새로운 IP 주소 획득시 로컬 네트워크 상의 다른 호스트나 라우터에게 자신의 IP와 MAC 바인딩을 갱신해달라고 요청. 프록시(Proxy) ARP 라우터가 외부 네트워크에 존재하는 호스트의 ARP 요청에 대해서 자신의 하드웨어 주소로 응답. ICMP(Internet Control Message Protocol) IP 패킷 전송의 오류에 관한 보고 기능과 네트워크 상태 진단 기능을 통해 IP를 보조하는 프로토콜 ICMP 메시지 오류 보고 메시지: 라우터나 호스트에서 IP 패킷을 전달할 때 문제가 발생하였을 경우 사용 네트워크 진단 기능: 라우터나 네트워크 상태에 대한 정보를 얻고자 할 때 사용 ICMP 패킷 포맷 IP헤더의 프로토콜 필드 값을 1로 설정하여 캡슐화 메시지 타입 - ICMP 메시지 종류를 기술 코드 - 메시지 타입에 따라서 세분화할 필요가 있는 경우 사용 체크섬 - ICMP 메시지에 대해 체크섬을 계산하여 패킷의 오류를 검사 메시지 의존 - 메시지 타입에 따른 추가적인 헤더 정보가 포함 메시지 정보 - 메시지 타입에 따라 전달될 정보를 저장 목적지 도달 불가 메시지(Destination Unreachable Message) 패킷이 중도에 폐기될 때 사용되는 메시지 메시지 타입 필드 값은 3, 코드 필드에는 전송 실패 정보가 기록. 정보 필드에는 폐기되는 패킷의 헤더와 데이터의 상위 8바이트가 저장된다. 시간 초과 메시지 (Time Exceeded Message) 패킷이 목적지에 전달되기 전에 시간 초과로 폐기되는 경우 사용. 메시지 타입 필드 값은 11, 코드 필드에는 TTL 초과인 경우 0, 재결합 시간 초과인 경우에는 1이 설정된다. Traceroute명령에서 주로 사용됨. 파라미터 문제 메시지(Parameter Problem Message) 패킷 헤더 부분에 문제가 발생한 경우에 사용되는 메시지 메시지 타입 값은 12, 코드 필드에는 헤더 오류인 경우 0, 원하는 필드가 없는 경우 1을 사용. 메시지 의존 필드의 상위 8비트는 포인터로써 사용, 패킷 헤더의 어떤 부분에 문제가 발생하였는지 가르킨다. 송신 억제 메시지(Source Quench) 패킷 흐름을 위해 사용되는 메시지 (IP 프로토콜은 흐름제어 기능이 존재하지 않음) 과도한 패킷의 유입으로 라우터에서 패킷을 버려야 할 때 송신 호스트로 패킷의 폐기를 알리기 위해 사용. 메시지 타입 필드 값 4, 코드 필드 값 0 사용. 재지정 메시지(Redirection Message) 라우터가 호스트로부터 수신한 패킷의 송수신 주소를 확인하여 다른 라우터가 라우팅하는 것이 더 효율적이라고 판단되면 라우팅 경로를 변경하도록 재지정 메시지를 호스트로 전송한다. 라우터는 수신한 패킷을 폐기하지 않고 재지정된 라우터로 직접 전달. 메시지 타입 필드 값 5 사용, 코드 필드에는 재지정될 라우터 주소가 삽입된다. 메시지 의존 필드에는 새로운 라우터 주소가 지정되며, 메시지 정보 필드에는 패킷 헤더와 데이터의 상위 8바이트가 포함됨. ICMP 메시지를 발생시키지 않는 패킷 ICMP 메시지를 라우팅하거나 전달하는 경우 - ICMP를 포함한 IP datagram에 대해서는 ICMP를 발생시키지 않음. 브로드캐스트 혹은 멀티캐스트 패킷인 경우 분할된 패킷 중 첫 패킷이 아닌 경우 송신 주소가 특수한 IP주소(루프백 주소, 임의의 호스트)인 경우 ICMP 쿼리(Query) 메시지 네트워크 상황을 파악하기 위해 사용 기본적으로 ICMP 오류 메시지와 동일한 포맷을 사용하지만, 메시지 의존 필드를 식별자와 순서 번호 필드로 나누어 사용. 식별자와 순서 번호는 여러 개의 메시지를 보내는 경우 각각을 구분하기 위해 사용. 에코 요청/응답 메시지(Echo Request and Reply) 두 호스트 사이에 통신이 가능한지 검사할 때 사용되는 메시지 타입 필드 값은 요청인 경우 8, 응답인 경우 0, 코드 값은 0 응답 메시지 데이터 필드에는 요청 메시지의 데이터 필드 값이 그대로 복사됨. Ping 명령어를 통해 에코 메시지를 사용할 수 있다. 타임스탬프 요청/응답 메시지(Timestamp Request and Reply) 패킷 전송 시간 측정 메시지 메시지 타입 필드는 요청인 경우 13, 응답인 경우 14, 코드 필드 값은 모두 0이다. 데이터 필드 출발 시간(Original timestamp): 송신할 때의 시간 도착 시간(Receive timestamp): 수신할 떄의 시간 전송 시간(Transmit timestamp): 수신 호스트에서 응답 메시지를 전송할 때의 시간 측정 시간들은 세계 표준시(Universal time)를 숫자값으로 표현한다.(동기화되지 않은 경우, 시간 값을 절대적으로 신뢰할 수 없음) 주소 마스크 요청/응답 메시지(Address Mask Request and Reply) 호스트가 서브넷 마스크 값을 얻을 때 사용하는 메시지 라우터에서 응답 메시지를 전송한다. 타입 필드 값은 요청인 경우 17, 응답인 경우 18을 사용, 코드 필드 값은 모두 0. 응답 메시지의 데이터 필드에는 서브넷 마스크 값이 포함됨. 라우터 요청, 광고 메시지(Router Solicitation and Advertisement) 호스트가 네트워크 정보를 알고 싶을 때 사용하는 메시지 라우터는 라우팅 정보를 포함한 라우터 광고 메시지를 방송 라우터는 동일 네트워크에 존재하는 모든 라우터에 대한 정보도 함께 전송. 라우터마다 우선값을 주어 호스트가 디폴트 라우터를 자동으로 설정할 수 있게 한다. 출처: 정진욱, 김현철 공저. “TCP/IP와 인터넷”, pp 50-57. 2004. (주)생능출판사","link":"/2020/05/08/major/Internet%20Protocols/InternetProtocols-5/"},{"title":"Ch 2. IPv4(1) - IP헤더","text":"IP(Internet Protocol)IP는 OSI 참조 모델의 네트워크 계층 기능을 수행하며 패킷 전송을 위한 주소 정의 및 관리와 라우팅을 담당한다. IP의 특징 비신뢰성(Unreliable) 가능한 범위 내에서 패킷을 목적지까지 전달하는 최선형 서비스(Best Effort Service) 비접속형(Connectionless) 연결 설정 없이 패킷을 전송 서로 다른 경로로 패킷이 전송될 수 있으며, 순서도 바뀔 수 있다. 주소 지정 네트워크 내의 노드를 고유하게 지정하기 위한 수단으로 IP주소를 사용 경로 결정 목적지 IP주소를 기반으로 패킷 전달 경로를 판단(Routing Protocol). IP패킷 구성 IP패킷은 헤더 필드와 데이터 필드로 분리. 헤더 필드에는 패킷을 목적지까지 전송하기 위한 값을 포함. 헤더의 길이는 확장헤더를 포함한 헤더의 길이이다. 데이터 필드에는 TCP, UDP와 같은 전송 계층으로부터의 데이터 유닛(IDU)이 포함되어 있다. 1. 버전 IP 프로토콜의 버전을 의미(IPv4의 경우 버전 필드 값은 4). 2. 헤더 길이 옵션 필드를 포함한 헤더의 총 길이를 4바이트 단위로 표시 (확장 헤더를 사용하지 않는 경우 20byte로 헤더 길이 필드 값은 5). 3. 서비스 타입(Type-Of-Service) 우선권 필드 3비트, TOS(Type-Of-Service)필드 4비트, 예약 필드 1비트로 구성되어 있음. 우선권 필드 - 패킷의 우선순위 정의(혼잡시 폐기할 패킷을 우선권 필드 값으로 결정하며 데이터의 중요도를 나타냄). TOS 필드 - 최소 지연(Delay), 최대 처리량(Throughput), 최대 신뢰성(Reliability), 최소 비용(Cost)을 4비트로 나타내어 4비트 중 1비트만 set하는 방식으로 타입을 표시. 해당 필드 값에 명시된 TOS를 지원하는 서브넷으로 패킷을 라우팅 시키는데 사용됨. 예약 필드 - 0의 값을 갖도록 예약되어 있어 MBZ(Must Be Zero)라고도 불림, 라우터와 수신 측은 이 필드 값을 무시함. TOS필드 의미 1000 최소 지연 0100 최대 처리 0010 최대 신뢰성 0001 최소 비용 4. 전체 길이(Total Length) 헤더와 데이터를 포함한 IP 패킷의 전체 길이를 바이트 단위로 표현. IP패킷의 최대 크기는 $2^{16}-1=65,534 byte$로 최대 값은 65534. 5. 식별자(Identification) 패킷 단편화(Fragmentation)로 인한 패킷을 구분하는 역할. 동일한 데이터로부터 분할된 패킷들은 같은 식별자 값을 가짐. 6. 플래그(Flags) 예약, 단편화 금지, 추가 단편화 비트의 3비트로 표현됨 예약(Reserved) - 항상 0의 값을 갖도록 예약되어 있음. 단편화 금지(Do not Fragment) - 해당 패킷에 대해 단편화를 하지 않도록 설정, 만약 서브넷이 단편화를 필요로 하고, 단편화 금지 비트 값이 1이라면 패킷을 폐기함. 추가 단편화 비트(More Fragment) - 비트 값이 1이라면 추가적인 단편화 패킷이 있음, 0이라면 마지막 패킷임을 명시함. 7. 단편화 옵셋(Fragment Offset) 패킷 재조립(reassembly)시 분할된 패킷 간의 순서에 대한 정보 포함. 전체 데이터에서 분할된 패킷의 상대 위치를 8 바이트 단위로 기술. 8. Time-To-Live(TTL) 패킷이 경유할 수 있는 최대 홉 수(hop count)를 의미. 패킷이 라우터를 통과할 때마다 TTL 값은 1씩 감소. TTL 값이 0이 되면 패킷은 폐기되고 송신 측으로 ICMP메시지를 전달. 9. 프로토콜(Protocol) 데이터가 어떤 프로토콜을 사용하는지 나타내는 필드 ICMP프로토콜을 사용한다면 1, TCP프로토콜을 사용한다면 6, UDP프로토콜을 사용한다면 17의 값을 갖는다. 10. 헤더 체크섬(Header Checksum) IP 패킷 헤더의 오류 발생을 검사하기 위한 필드 11. 옵션 확장 헤더의 필드 값으로, 다음과 같은 옵션이 존재한다. (1) IP 패킷 헤더 옵션 경로 추적이나 네트워크 상황 파악 등 특정 목적을 위해 사용. 하나 이상의 옵션을 동시에 사용할 수 있음. 코드 필드(Code Field) -복사 필드(Copy Field): 단편화시 단편화된 모든 패킷에 헤더 옵션 필드의 복사 여부를 결정함.(copy=1: 모든 fragment에 option을 복사함.) 클래스 필드(Class Field): 값이 0인 경우 패킷 제어를 위해 사용, 2인 경우 디버깅 혹은 측정을 위해 사용.옵션 종류 옵션 종료(End of Option) 옵션 필드의 끝을 나타내는 1바이트 옵션. 남은 옵션종류 공간을 무동작 옵션(NoOp)로 채워넣는다. 옵션 종료는 마지막 옵션에서만 사용 가능 옵션 종류 코드값을 0으로 하여 사용. 무동작(No Operation) 옵션 간의 경계로 사용되는 1바이트 옵션. 다른 옵션을 4바이트 경계에 맞추기 위해 사용한다. 옵션 종류 코드값을 1로 하여 사용. 엄격한 소스 루트(Strict Source Route) 전달 경로를 송신 측에서 미리 지정하고 네트워크 장비(라우터)는 경로를 따라서만 패킷을 전송하는 옵션. 옵션 종류 코드 값을 137로 하여 사용. 포인터 값은 홉을 지날 때마다 단계적으로 증가하여 다음 경유할 주소를 가르킴 기술된 경로대로 패킷을 전송할 수 없다면 패킷을 폐기하고 ICM 메시지를 송신측으로 전송. IP헤더에 명시된 수신 측 주소에 도달한 경우 해당 옵션 패킷의 포인터에 지나온 IP 주소와 수신 측 주소를 교환, 포인터를 다음 IP주소 정보가 담긴 필드를 가르키는 포인터로 변경함으로써 연속적인 이동 경로의 설정이 가능하다. 옵션 패킷의 IP주소에 이동한 경로가 기록되므로 패킷의 반환시 기록된 IP주소를 역방향으로 찾아 루트를 재설정 할 수 있음(ex ICMP). 경유할 IP주소를 일일이 설정해주어야하므로 출발지와 목적지의 IP주소 뿐만 아니라 경유할 IP주소도 미리 기록되어있어야한다.(주소 목록에 저장되지 않은 주소는 경로로 사용할 수 없음) 느슨한 소스 루트(Loose Source Route) 옵션 종류 코드 값 131 사용. 엄격한 소스 루트와 비슷하지만, 주소 목록에 없는 경로라도 사용 가능하다는 점에서 차이점이 존재. 주어진 IP주소를 모두 경유하되, 도중에 명시되지 않은 경로를 갈 수 있다. 레코드 루트(Record Route) 패킷의 전달 경로를 모두 기록. 옵션 종류 코드 값 7을 사용. 포인터는 라우터의 주소를 기록할 장소를 가르킨다. IP 옵션의 총 길이가 40바이트로 제한되어 있으므로, 기록할 수 있는 경로의 수는 제한되어 있음. 타임스탬프(Timestamp) 패킷이 경로상의 라우터에 도착하는 시간을 기록. 옵션 종류 코드 값 68. 오버플로우 필드가 존재하며 공간부족으로 기록하지 못한 라우터의 수를 명시한다. 플래그 필드는 주소나 시간 둘 중 하나만을 기록할 것인지 모두 기록할 것인지를 명시함. 출처: 정진욱, 김현철 공저. “TCP/IP와 인터넷”, pp 36-42. 2004. (주)생능출판사","link":"/2020/05/06/major/Internet%20Protocols/InternetProtocols-3/"},{"title":"Ch 2. IPv4(2) - IP주소 관리 기법","text":"IP주소 체제IP주소 모든 장비들이 갖는 영구적이지 않고 고유한 논리적 네트워크 식별자. 클래스별 분류 IP주소는 네트워크를 구분하기 위한 네트워크 식별자(netid)와 네트워크 내에서 호스트를 구분하기 위한 호스트 식별자(hostid)로 구성. 호스트 식별자는 0.0.0.0…(네트워크 호스트)과 255.255.255.255….(브로드캐스트)를 제외하여 사용 네트워크와 호스트의 주소 개수에 따라 5개의 클래스로 구분할 수 있음 클래스 A - 처음 1비트 값이 “0”인 주소, 7비트를 netid에 할당하며 나머지 24비트를 모두 hostid로 사용, 큰 규모의 호스트를 갖는 기관에서 사용한다. 클래스 B - 처음 2비트 값이 “10”인 주소, 15비트를 netid에 할당하고 나머지 16비트를 모두 hostid로 사용 클래스 C - 처음 3비트 값이 “110”인 주소, 네번째 바이트만 hostid를 위해 주어짐, 네트워크마다 $2^8-2=254$개의 호스트를 수용할 수 있기 때문에 작은 규모의 네트워크에서 사용. 클래스 D - 처음 4비트 값이 “1110”인 주소, netid와 hostid의 구분이 없으며, 전체 주소가 멀티캐스트용으로 사용됨. 클래스 E - 처음 4비트 값이 “1111”인 주소, 추후 사용을 위해 예약된 주소 전송 방법에 따른 분류 유니캐스트(Unicast) - 하나의 송신자가 하나의 수신자에게 패킷을 보내는 방식의 주소 멀티캐스트(Multicast) - 하나의 송신자가 다수의 수신자에게 패킷을 보내는 일대다 방식의 패킷 전송 주소, 네트워크가 멀티캐스트를 지원해야 하며, 그룹 식별자(group id)로 구분함. 브로드캐스트(Broadcast) - 송신자가 네트워크의 모든 호스트에게 패킷을 보내는 방식, 호스트 식별자 필드를 모두 1((netid). 255. 255. 255. …)로 설정한다. 특별한 IP주소 네트워크 주소(network address) 네트워크 자체를 의미함.(실체가 존재하지 않으므로 송/수신이 불가능하다) 라우팅 프로토콜에서 네트워크를 지칭할 때 사용 관리목적의 주소이므로 패킷의 송신지나 수신지 주소로써 사용할 수 없음. 직접적 브로드캐스트(directed broadcast) 라우터가 네트워크의 모든 호스트로 패킷을 보낼때 사용. 수신 주소로만 사용됨.(송신 불가) 제한적 브로드캐스트(limited broadcast) 네트워크에 있는 모든 호스트로 패킷을 보낼 때 사용. 제한적 브로드캐스트는 라우터 외부로 패킷을 전송하지 않는다. 수신 주소로만 사용, 송신 불가. 네트워크의 한 호스트(host on network) 임의의 호스트를 지칭할 떄 사용. 송신 주소로만 사용. 루프백(loopback) 주소 소프트웨어 테스트를 위해 사용. 해당 주소로 데이터를 전송하면 물리 계층까지 전달되지 않고 다시 상위 계층으로 전달되어 자기 자신에게 데이터가 전송된다. 수신 주소로만 사용하며 송신 불가. 서브네팅(subnetting) 하나의 큰 네트워크를 몇 개의 작은 논리적인 네트워크로 분할하여 사용하는 방식 호스트 식별자를 서브넷 식별자와 호스트 식별자로 세분화. 서브넷 마스킹(masking): IP 주소로부터 서브넷 주소만을 식별할 수 있는 방법 네트워크에서 필요한 호스트의 수, 필요한 네트워크의 수를 파악하여 필요한 만큼 서브넷마스크를 변경. 기존 주소에 서브넷 마스크를 곱하여 subnet 주소가 결정된다. 서브넷 식별자로 네트워크가 한번 더 분리되므로 여분의 주소를 다른 네트워크로 사용할 수 있어 IP주소의 낭비/부족 현상을 방지할 수 있음 슈퍼네팅(supernetting) C 클래스에서 사용할 수 있는 호스트의 수를 254개로 제한. 여러 개의 C 클래스 주소를 묶어 하나의 네트워크로 구성하는 방법. 네트워크 식별자 중 공통되지 않은 Bit를 호스트 식별자로 사용하여 다수의 네트워크를 통합 CIDR(Classless Inter-Domain Routing) 네트워크 식별자 범위를 자유롭게 지정할 수 있도록 하여 IP 주소 운영의 융통성을 제공하는 방법. 네트워크 주소를 자유롭게 설정할 수 있어 IP주소의 낭비를 방지할 수 있다. 네트워크 주소에 해당하는 비트 수를 “/21”과 같이 명시하여 네트워크 주소와 호스트 주소의 경계를 찾음. 출처: 정진욱, 김현철 공저. “TCP/IP와 인터넷”, pp 43-49. 2004. (주)생능출판사","link":"/2020/05/06/major/Internet%20Protocols/InternetProtocols-4/"},{"title":"Ch 2. IPv4(4) - 멀티캐스팅","text":"멀티캐스트 동일한 정보를 여러 사람에게 전송시 필요한 몇몇 호스트들에만 메시지를 전달하는 방법 전달받을 호스트의 수만큼 데이터를 패킷을 보유해야하는 유니캐스트에 비하여 멀티캐스트는 하나의 패킷을 전송하여 라우터에서 복사하여 라우터 내 각 호스트들에게 전달하는 방식이므로 대역폭 낭비와 지연 시간을 줄일 수 있음. 멀티캐스트를 지원하지 않는 라우터는 멀티캐스트를 지원하는 라우터 사이에서 유니캐스트와 같이 작동하는 터널링 기법을 사용. 멀티캐스트의 기본 요소호스트 그룹 정의(multicast group) 멀티캐스트 패킷을 수신하는 호스트들의 집합 각각의 그룹은 멀티캐스트 주소로 구분 그룹 관리(group management protocol) 멀티캐스트 그룹은 필요에 따라 추가, 삭제되는 동적인 구조를 갖는다. 그룹 관리를 위한 새로운 메커니즘으로 IGMP사용 라우팅 경로 설정(multicast routing protocol) 목적지에 도달하기 위한 경로는 다양하게 존재한다. 트리를 구성하여 라우트간 빠른 경로를 탐색한다. 멀티캐스트 주소 IPv4 멀티캐스트 주소는 클래스 D 주소를 사용. 사용가능한 범위는 224.0.0.0 ~ 239.555.555.0 특정 IP주소는 예약되어 있음 224.0.0.1 - 로컬 서브넷 안에 있는 모든 시스템 224.0.0.2 - 로컬 서브넷 안에 있는 모든 라우터 224.0.0.5 - OSPF(Open Shortest Path First)를 지원하는 모든 라우터 224.0.0.9 - 모든 RIPv2 라우터 멀티캐스트 주소의 MAC주소 변환 멀티캐스트 MAC 주소의 상위 25비트를 이더넷에서 멀티캐스트 전송을 위해 이미 정해진 코드인 “0000 0001 0000 0000 0101 1110 0”으로 지정. 멀티캐스트 MAC 주소의 나머지 23비트는 멀티캐스트 IP 주소의 뒷부분 23비트를 복사 멀티캐스트 IP 주소는 32비트이므로 5비트는 변환과정에서 사용하지 않고 버려지므로 32개의 멀티캐스트 IP주소는 같은 MAC주소로 변환됨 (원하지 않는 호스트에서 패킷을 수신할 수 있음) IP 계층에서 패킷의 IP주소를 확인해서 원하지 않는 멀티캐스트 그룹의 패킷을 폐기함.(double checking) IGMP(Multicast Group Management Protocol) 멀티캐스트를 지원하는 라우터가 멀티캐스트 그룹에 가입한 네트워크 내의 호스트를 관리하기 위해 사용하는 프로토콜. IP 상위 계층에 존재하며 IP 패킷으로 캡슐화한다. IGMP 포맷 타입 - IGMP 패킷의 종류를 정의. 타입 필드 이름 설명 0x11 멤버쉽 문의 멀티캐스트 라우터가 호스트들에게 멀티캐스트 그룹 사용 여부를 문의하는 메시지 0x16 멤버쉽 보고 호스트가 새로운 멀티캐스트 그룹에 가입하거나, 가입된 그룹을 계속 사용하는 것을 보고한느 메시지 0x17 그룹 탈퇴 호스트가 멀티캐스트 그룹 사용을 중단하는 경우 라우터에 보내는 메시지 최대 응답 시간(Max Resp Code) - 라우터가 호스트에게 멀티캐스트 그룹 사용 여부를 묻고 난 후, 응답 메시지를 기다리는 최대 시간 멤버쉽 문의 메시지에만 사용되며 그룹을 계속 사용하려는 호스트는 정해진 시간 내에 멤버쉽 보고 메시지를 라우터에게 전송해야함. 체크섬 - IGMP 메시지의 오류 검사를 위한 체크섬 필드 그룹 주소 - IGMP 메시지가 속한 그룹 주소 멤버쉽 문의 메시지 중 그룹 한정 문의의 경우 특정 멀티캐스트 그룹 주소가 표시됨. 멤버쉽 요청 중 모든 호스트에 대해 문의하는 경우 0.0.0.0으로 표시 IGMP 동작 그룹 가입 호스트가 새로운 멀티캐스트 그룹에 가입하기 원하는 경우 맴버쉽 보고 메시지를 라우터로 전송 호스트에서 여러 프로세스가 동일한 멀티캐스트 그룹에 가입하는 경우에도 맴버쉽 가입 메시지는 한번만 전송된다. 멤버쉽 감시 호스트들이 계속 그룹 멤버쉽을 원하는지 감시하기 위해서 주기적으로 멤버쉽 문의 메시지를 전송. 멤버쉽 문의 메시지를 보낼 때는 최대 응답 시간 필드에 특정 값을 부여하여 보고 메시지를 기다리는 시간 규정. 멤버쉽 응답 멀티캐스트 그룹을 계속 사용하고자 하는 경우, 멀티캐스트 주소를 이용하여 라우터에 멤버쉽 보고 메시지를 보냄. 멤버쉽 보고 메시지 충돌을 피하기 위해 각 호스트는 일정 시간을 기다린 후 전송한다. 호스트마다 대기 시간을 다르게 하기 위해 대기 시간은 0 ~ 최대 응답 시간 사이에서 임의로 설정됨. 그룹 멤버 중 하나의 호스트만 멤버쉽 응답을 하여 그룹을 유지할 수 있다. 멤버쉽 탈퇴 더 이상 그룹 사용을 원하지 않는 호스트는 그룹 탈퇴 메시지를 라우터에 전송 라우터는 그룹 내 모든 호스트들이 그룹을 탈퇴하고자 할 때에만 그룹을 삭제한다. 그룹 탈퇴 메시지는 그룹에서 마지막으로 탈퇴하는 경우나 마지막으로 탈퇴하는지 모르는 경우에만 전송한다. 출처: 정진욱, 김현철 공저. “TCP/IP와 인터넷”, pp 57-64. 2004. (주)생능출판사","link":"/2020/05/09/major/Internet%20Protocols/InternetProtocols-6/"},{"title":"Ch 4. TCP(1) - TCP 헤더, 타이머","text":"TCP(Transmission Control Protocol) 전송 제어 프로토콜의 약자 IP를 통해 확인된 목적지 주소로 데이터를 전송하는 프로토콜로서 전송 계층(4계층)의 기능을 수행 두 호스트 간에 전송되는 데이터와 메시지의 형식을 정의함 TCP의 특징 연결형 : IP계층 위에 가상의 회선을 설정하여 종단간 데이터 송/수신 서비스를 제공 신뢰성 : 데이터 송/수신 확인을 통한 신뢰성있는 통신 서비스 제공 (ACK 필드) 흐름 제어 : 송/수신측의 데이터 처리 속도 차이를 해결하기 위한 방법, 처리할 수 있는 범위 내에서 데이터를 보내도록 제어 (슬라이딩 윈도우, 슬로우 스타트) 혼잡 제어 : 송신측의 데이터 전달과 네트워크의 데이터 처리 속도 차이를 해결하기 위한 방법, 혼잡 현상을 방지하거나 제어 (혼잡 회피) 스트림 통신 : 데이터를 바이트 단위로 나누어 전송(버퍼 사용) 포트(Port) 호스트 내의 프로세스가 통신을 수행하기 위해 할당 받는 고유 번호 데이터 링크 계층(2계층)의 MAC 주소, 네트워크 계층 (3계층)의 IP 주소와 같이 전송 계층(4계층)에서 사용하는 식별 번호 포트 번호는 16비트로 이루어져 있으며 번호의 범위에 따라 사용 목적이 나뉘어져 있음 0 ~ 1023번 : 잘 알려진 포트(well-known port), HTTP(80), FTP(20)와 같은 포트로 특정한 쓰임새를 위해 IANA에서 할당한 TCP, UDP포트 1024 ~ 49151번: 등록된 포트(registered port), 기업이나 사업자들을 위해 IANA에서 할당한 포트 49152 ~ 65535번: 동적 포트(dynamic port), 일반 사용자들이 사용할 수 있는 포트 포트 번호는 IP주소 뒤에 콜론으로 표기됨 (127.0.0.1:61000) TCP 소켓 TCP/IP 통신 인터페이스 두 프로세스의 소켓은 프로토콜, 송신자 IP주소, 송신자 프로세스 번호, 수신자 IP 주소, 수신자 프로세스 번호로 식별 TCP 헤더 소스 포트번호 세그먼트(segment)를 전송하는 응용 프로그램의 포트번호 목적지 포트번호 세그먼트를 수신하는 응용 프로그램의 포트번호 순서번호(SEQuence number) 데이터 스트림의 순서를 구분 32비트의 부호 없는 번호 $2^{32}-1$의 값이 초과되면 다시 0부터 시작(Overflow) 확인 응답번호(ACKnowledgement sequence number) 다음 세그먼트로 받고자 하는 순서 번호를 나타냄 정상적으로 수신된 세그먼트에 대하여 ACK필드 값은 수신된 SEQ 필드 값 중 가장 큰 SEQ 값+1의 값을 갖는다. 헤더 길이 4바이트 단위로 기술됨, 최대 길이는 60바이트(필드 값 15) 플래그 비트 URG : 긴급 포인터 존재 ACK : 확인 응답번호 존재 PSH : 데이터를 가능한 빨리 응용 계층으로 보내야 함을 표시 RST : 연결을 재설정 SYN : 송신측 응용 프로그램의 연결의 초기화를 위해 순서번호를 동기화 FIN : 송신측 응용 프로그램의 연결 해제 윈도우 크기(Window size) 흐름 제어를 위해 사용 수신 가능한 데이터의 양을 바이트 단위로 알림 16비트로 표현되며 최대 값은 $2^{16}-1 = 65,535$바이트 옵션 필드의 스케일 펙터를 이용하여 더 큰 윈도우 크기 값을 가질 수 있음 체크섬 TCP 헤더와 데이터의 에러를 검출 IPv4 프로토콜 이용시 체크섬 검사는 총 2번 수행됨(IP계층, TCP 계층) 긴급포인터(URGment pointer) 긴급 데이터의 마지막 위치를 포인터로 저장 긴급 모드로 받은 수신 프로그램은 긴급 포인터를 통해 데이터로 빠른 접근 가능 TCP헤더 옵션옵션의 끝(End of Option) 코드 값: 0x00 마지막 옵션임을 나타냄 무작동(NO-OPeration) 코드 값: 0x01 TCP헤더를 4byte단위로 나타내기 위해 옵션들 사이에 한 바이트로 존재 최대 세그먼트 크기(Maximum Segment Size) 코드 값: 0x02 수신할 수 있는 가장 큰 패킷의 크기를 정의, TCP헤더를 제외한 TCP데이터 크기의 최대 값을 바이트 단위로 표현함 16비트로 표현되며 최대 값은 65,535바이트 윈도우 스케일 펙터(Window Scale: WSCALE) TCP 헤더에서 윈도우 크기는 16비트로 65,535바이트로 제한되어 있음(이는 고속 네트워크에서 처리량을 최대화 하기에는 부족함) 스케일 펙터를 두어 윈도우 크기를 2배씩 증가시킬 수 있음 새로운 윈도우 크기 = 기본 헤더에 정의된 윈도우 크기$\\times 2^{윈도우 스케일 펙터}$ 타임스탬프(Timestamp) 신뢰성 있는 데이터의 전송을 위해 누락된 패킷의 누락을 확인할 수 있어야함 타이머를 설정하여 타이머 내에 확인응답을 받지 못한 패킷은 재전송됨 (패킷의 재전송) 타이머의 적절한 시간 설정을 위해 패킷의 왕복시간인 RTT(Round-Trip Time)의 측정이 필요 타임스탬프 옵션은 코드와 길이 1바이트, 타임 스탬프 값과 타임 스탬프 에코 응답 4바이트로 총 10바이트 크기 송신 측은 전송 시의 시간을 타임스탬프 값에 채움 수신 측은 확인 응답 전송 시 타임 스탬프 에코 응답 필드에 원래의 타임스탬프 값을 넣어 전송 확인 응답 메시지를 수신한 송신측은 현재의 시간과 타임스탬프 에코 응답에 기록된 시간의 차로써 구함 (RTT측정) TCP 타이머와 재전송 TCP 송신 측은 수신 측으로부터 긍정 확인 응답만을 받음 세그먼트가 손실되거나 손상되었을 경우 이를 확인할 방식이 필요 재전송 타이머를 설정하여 타이머가 종료되면 세그먼트가 손실되거나 손상되었음을 가정하고 재전송 네트워크 상황이 혼잡하거나 목적지까지의 경로가 길 경우 TCP 세그먼트를 전송하고 확인 응답(ACK)를 받기까지 긴 시간이 걸릴 수 있음. 적응적(adaptive) 재전송 알고리즘을 사용하여 재전송 타이머의 값을 설정 RTT(Round Trip Time) 측정 특정 세그먼트를 전송한 시간과 해당 세그먼트에 대한 확인 응답이 도착한 시간 차로 측정 재전송 타이머는 적응적으로 재전송 타임아웃 시간을 결정하기 위해 지속적인 RTT 측정을 수행 RTT는 매우 가변적이므로 SRTT(Smoothed Round Trip Time)값을 이용 SRTT = a \\times SRTT + (1-a) \\times RTT \\ \\ \\ (a=0.8 \\sim 0.9) SRTT를 기초로 하여 재전송 타임아웃인 RTO(Retransmission TimeOut)를 설정 RTO = min(타임아웃 \\ 상한치,max(타임아웃 \\ 하한치,b \\times SRTT)) \\ \\ \\ (b=1.3 \\sim 2.0)Karn의 알고리즘 RTT 계산은 세그먼트 재전송으로 인해 문제가 발생할 수 있음 재전송 시 동일한 두개의 세그먼트를 보냈기 때문에 수신된 확인응답 세그먼트가 어떤 세그먼트에 대한 것인지 판단하기 어려움 재전송 타이머가 종료되고 재전송을 수행한 경우에는 RTT 계산을 수행하지 않고 RTO 값만을 증가 TCP Persist 타이머 수신측으로부터 0의 윈도우 크기를 수신하면 수신측 버퍼에 여유가 생겨 윈도우 크기를 새로 전송할 때까지 송신측의 전송이 중단 수신측으로부터 윈도우 크기를 나타내는 확인응답 세그먼트가 손실될 경우 송신측은 윈도우 크기가 갱신되지 않아 송신하지 않고 계속하여 데이터의 송/수신은 이루어지지 않음 TCP 송신측은 윈도우 크기가 0인 세그먼트를 수신하면 Persist 타이머를 시작 Persist타이머가 타임아웃 되면 1바이트로 이루어진 탐색(probe) 세그먼트를 주기적으로 송신하여 수신측 윈도우 크기를 확인 TCP Keepalive타이머 일정 기간동안 데이터를 전송하지 않는 연결의 해제를 위한 TCP keepalive 데이터를 사용 연결된 후 클라이언트의 중지에도 FIN 세그먼트가 없다면 서버 측은 연결을 유지함 유후 연결을 감지하기 위해 TCP는 keepalive 타이머를 사용하고 타이머 종료마다 탐색 세그먼트 전송 탐색 세그먼트에도 응답이 없는 경우 서버는 TCP 연결을 종료 TCP Time-waited 타이머 TCP 연결 종료 세그먼트의 송/수신시에 즉시 TCP 연결을 종료한 경우 지연된 잔여 세그먼트에 의하여 이후 생성된 연결에 영향이 미칠 수 있음 TCP 연결 종료 세그먼트를 송/수신시에 완전히 종료하지 않고 Time-waited 타이머를 설정 Time-waited 타이머 기간동안 연결을 유지하여 지연된 세그먼트를 처리 Time-waited 타이머는 보통 세그먼트의 예상 생존시간을 두배로 설정 출처: 정진욱, 김현철 공저. “TCP/IP와 인터넷”, pp 194-233. 2004. (주)생능출판사","link":"/2020/07/03/major/Internet%20Protocols/InternetProtocols-8/"},{"title":"Ch 3. IPv6","text":"IPv6IPv6의 특징확장된 주소 공간 IPv4의 주소 부족 문제, 보안 문제를 해결하기 위하여 주소 체계를 128비트로 확장한 인터넷 프로토콜 주소. 헤더 단순화 IPv4에서 자주 사용하지 않는 헤더 필드를 제거함. (단편화 관련 필드, 체크섬 필드 삭제) 추가적으로 필요한 기능은 확장헤더를 사용하여 수행한다. IPv6의 기본 헤더는 40바이트 보안 / 개인보호에 관련된 기능 지원 보안과 관련된 인증절차, 데이터 무결성 보호, 선택적인 메시지 발신자 확인 기능 등을 프로토콜 차원에서 지원함. 확장 헤더를 이용하여 종단간 암호화 기능을 지원, 패킷에 대한 변조 방지. 자동 주소 설정 IPv6에서는 라우터가 제공하는 네트워크 프리픽스 정보와 MAC주소를 사용하여 자동으로 로컬 IPv6 주소를 생성한다. 상태 보존형 자동 설정 (Stateful auto-configuration) DHCP 서버로부터 모든 네트워크 정보를 받는 방식 주소를 요청받은 DHCP는 호스트에 할당 가능한 주소를 전달한다. 장점: 주소를 효율적으로 이용하고 인증과정을 통해 보안 유지가 가능 단점: 서버에 대규모 데이터베이스가 준비되어야 함 비상태형 자동 설정(Stateless auto-confuguration) 호스트가 자신의 인터페이스 정보와 라우터에서 얻은 네트워크 정보를 이용하여 자체적으로 IPv6주소를 생성하는 방식 장점: 서버가 필요없음. 단점: 권한이 없는 엑세스가 들어오는 등 보안 문제가 발생할 가능성이 있다. IPv6 패킷 포맷 IPv4의 헤더 길이, 식별자, 플래그, 분할 옵셋(Fragment Offset), 헤더 체크섬 필드가 제거되었음. 서비스 타입(TOS)는 트래픽 클래스(Traffic Class) 필드로 대체됨 프로토콜 타입 필드와 TTL 필드는 다음 헤더(Next Header), 홉 제한(Hop Limit) 필드로 이름이 변경 트래픽 클래스 (Traffic Class) IPv6 패킷의 클래스 또는 우선 순위를 나타내는 8비트 필드 실시간 데이터와 같이 특별한 처리가 필요한 경우 특정 값을 사용하여 다른 패킷과의 차별화를 갖는다. IPv4 패킷으로 변환될 때 TOS 필드 값 계산에 활용됨 플로우 레이블(Flow Label) 동일한 서비스 클래스를 필요로하는 패킷들을 표현하는 20비트 필드 디폴드 값은 0이며 음성, 화상 등 실시간 데이터의 경우 이외의 값으로 저장된다. 페이로드 길이 (Paylod Length) 전송되는 데이터의 크기를 바이트 단위로 표현하는 16비트 필드 최대 $2^{16}$바이트 표현 가능하며 이보다 큰 데이터를 보낼 때 점보 페이로드 옵션을 사용한다. 점보 페이로드 옵션 사용시 필드 값은 0으로 설정. 다음 헤더(Next Header) IPv6 기본 헤더 이후의 확장 헤더 종류를 표현하는 8비트 필드 각 확장 헤더는 다음 헤더 필드 값을 통해서 알 수 있다. 홉 제한(Hop Limit) 패킷이 경유할 수 있는 최대 라우터 홉 수를 표현하는 8비트 필드 라우터를 지날때 마다 1씩 감소하여 0이 되면 패킷을 폐기하고 송신측에 ICMP메시지를 전달한다. 확장 헤더의 순서 확장 헤더는 정해진 순서로 사용되며 각 확장 헤더는 생략될 수 있지만 다른 순서로는 사용될 수 없다. 목적지 옵션 헤더: 확장 헤더에 두번 사용될 수 있음. 라우팅 헤더 앞 - 전송 경로에 있는 노드에서만 사용됨. 마지막 옵션 헤더 - 최종 목적지 호스트에서만 사용됨. 확장 헤더 포맷 다음 헤더 필드: 다음에 위치할 헤더의 종류를 1 바이트로 표현 헤더 길이: 확장 헤더 데이터 길이를 1 바이트로 표현 옵션 데이터 필드: 확장 헤더의 종류에 따라 다르게 사용 홉-바이-홉 옵션(Hop-by-hop option) 패킷의 전달 경로에 있는 모든 노드에서 해당 옵션을 처리하고자 하는 경우에 사용 경로상의 모든 라우터에 패킷을 전달하고자 하는 경우, 홉-바이-홉 옵션을 사용하여 한 번에 전송한다. 홉-바이-홉 옵션 타입 Pad1 - 한 바이트 패딩 데이터를 삽입하여 다른 옵션들을 4 바이트 단위로 정렬하기 위해 사용 PadN - 여러 바이트의 패딩을 위해 사용, 옵션 타입값 1 점보 페이로드 - 정해진 페이로드 길이(65,535 bytes)보다 큰 패킷을 전송하기 위해 사용, 옵션 타입값 194, 옵션 길이 4바이트로 사용 라우터 경고 - 패킷이 경유하는 모든 라우터에게 IP 패킷의 내용을 더 자세히 검사하도록 경고하는 옵션, 라우터 경고 옵션은 대역폭 예약 프로토콜인 RSVP(Resource Reservation Protocol)와 같이 경로상의 모든 라우터에서 특정한 처리를 필요로 하는 경우에 사용. 라우팅 헤더 옵션(Routing Header Option) 송신 측에서 지정한 경로를 따라서 패킷을 전송하도록 하는 옵션 다음 헤더 값 43 IPv4의 엄격한 소스 라우팅 옵션(라우터 타입 필드 값: 0)과 느슨한 소스 라우팅 옵션(라우터 타입 필드 값: 1)을 모두 지원 분할 헤더 옵션(Fragment Header Option) 전송 경로의 MTU보다 더 큰 패킷을 나누어 전송할 때 사용하는 옵션 다음 헤더 필드 값 44 분할 옵셋 필드: 전체 데이터에서 해당 패킷의 상대적인 위치를 8바이트 단위로 표현 M(More Fragment Flag) 비트: 전체 데이터에서 패킷이 마지막인지 아닌지를 나타내는 비트, 0인 경우 해당 패킷은 마지막 분할 패킷임을 명시함. 분할 식별자: 동일한 데이터로부터 분할된 패킷들은 같은 분할 식별자를 갖는다. 인증 헤더 옵션(Authentication Header Option) 수신한 패킷이 정확한 송신자로부터 올바른 메시지를 받았는지 확인하는 옵션 송신자 인증 및 데이터 무결성을 확인함. 다음 헤더 필드 값 51 목적지 헤더 옵션(Destination Header Option) 목적지 호스트에서만 특정 작업을 수행하고 싶을 때 사용하는 옵션 다음 헤더 필드 값 60 IPv6 주소IPv6 주소 구성 주소 형태를 기술하는 필드인 포맷 프리픽스(Format Prefix)와 순수한 주소를 나타내는 주소 필드로 구성 IPv6주소는 전송 방법에 다라 유니캐스트, 멀티캐스트, 애니캐스트 주소로 구분한다. IPv6 주소 표기법기본 표기법 128비트로 구성된 IPv6주소는 16비트씩 콜론으로 나누고 각 필드를 16진수로 표현한다. ex) 3ffe:1900:4545:0003:0200:f8ff:ffff:1105 주소 생략법 16비트씩 나눈 각 필드에서 상위 0은 생략하여 표현 0으로만 구성된 필드가 연속될 경우 필드 안의 0을 모두 삭제하고 2개의 콜론만으로 표현한다. (단, 생략된 필드의 크기를 유추하기 위하여 생략은 한번만 가능하다.) ex) 3ffe : 0501 : 0000 : 0000 : 0000 : 97ff : 0000 : efab -&gt; 3ffe : 501 : : 97ff : 0 : efab IPv4 주소의 IPv6 주소 표기 IPv4의 주소를 하위 32비트에 그대로 채우고, 나머지 상위 96 비트를 모두 0으로 채우는 방식을 사용한다. 하위 32비트는 IPv4형식으로 IPv6 주소를 표현할 수 있음. ex) 203.252.53.46 -&gt; : : 203.252.53.46 주소 프리픽스 표기 IPv6 주소 뒤에 “/“를 표기하고 네트워크 프리픽스 길이를 10진수로 표현한다. ex) 3ffe : 0501 : 97ff : : efab / 70 =&gt; 네트워크 프리픽스 주소의 길이는 70비트 출처: 정진욱, 김현철 공저. “TCP/IP와 인터넷”, pp 82-117. 2004. (주)생능출판사","link":"/2020/05/20/major/Internet%20Protocols/InternetProtocols-7/"},{"title":"Ch 4. TCP(2) - TCP 연결과 흐름제어","text":"TCP 연결 설정 능동적 열림(Active open) 클라이언트는 서버가 열어 놓은 포트로 TCP연결을 요청 수동적 열림(Passive open) 서버는 네트워크 응용을 수행하기 위해 정해진 포트를 열고 클라이언트의 요청을 기다림 세 방향 핸드쉐이크(Three-way handshake) 두 호스트는 TCP 연결을 위해 3개의 패킷이 송/수신되어야함 클라이언트는 서버에게 자신을 연결하라는 의미로 클라이언트 측 SEQ번호(순서번호)와 함께 SYN = 1 플래그가 저장된 세그먼트를 전송 이를 수신한 서버는 클라이언트에게 이에 대한 수락으로 ACK=1, 서버를 클라이언트에 연결하라는 의미로 SYN=1 플래그를 저장하며 클라이언트로부터 수신한 패킷의 SEQ+1를 ACK필드 값에, 서버 측의 순서번호를 SEQ필드에 저장하여 전송 서버로부터 SYN 패킷가 수신된 클라이언트는 서버에게 순서번호를 인지했다는 의미로 ACK=1플래그, ACK 필드 값은 수신한 패킷의 SEQ+1로 저장하여 전송 네 방향 핸드쉐이크(Four-way handshake) 두 호스트의 연결 종료는 4개의 패킷으로 이루어짐 연결을 종료하려는 클라이언트는 서버에게 FIN 플래그 값을 1로 설정하여 전송 이를 수신한 서버는 메시지 정상 수신에 대한 응답으로 ACK 메시지를 전송, 서버 측 응용 프로그램에게 클라이언트가 연결을 종료하려고함을 알림 응용 프로그램이 연결 종료에 대한 처리를 한 서버는 서버 측 또한 연결을 종료하기 위해 FIN=1 플래그가 담긴 ACK 메시지를 전송(ACK 필드 값은 2의 ACK 필드 값과 동일) 이를 수신한 클라이언트는 ACK 메시지를 보내 서버에게 해당 메시지가 정상 수신됨을 알려줌 이를 수신한 서버는 연결을 종료, 클라이언트는 서버로부터 누락된 패킷을 확인하기 위해 일정 시간 대기한 후 종료(Time-Waited 타이머) TCP 흐름 제어 데이터 통신에서 송신측의 데이터 전달 속도가 수신측의 처리 속도보다 빠르다면 데이터의 손실과 같은 문제가 발생할 수 있음 수신자가 송신되는 데이터의 크기 및 속도를 제어하여 문제의 발생을 방지 슬라이딩 윈도우 수신측에서 설정한 윈도우 크기만큼 송신측에서 수신측의 확인응답 없이 TCP 패킷을 전송할 수 있게 하여 흐름을 동적으로 제어하는 기법 윈도우 크기: 전송했으나 아직 확인 응답 받지 못한 데이터 크기 + ACK 없이 전송할 수 있는 데이터의 크기 송신 윈도우의 범위는 수신측 여유 버퍼 공간을 반영하여 동적으로 변화함(세그먼트의 window size 필드에 송신 측이 보낼 수 있는 윈도우 크기를 설정하여 전송) 비정상 윈도우 신드롬(Silly Window Syndrome) 슬라이딩 윈도우 사용의 부적절한 결과 송신측 응용프로그램이 전송하는 데이터 크기가 작은 경우 IP헤더, TCP헤더가 붙어 1바이트의 전송에도 40바이트가 추가적으로 전송되야 함, 이는 최악의 전송 효율을 나타냄 Nagle 알고리즘 비정상 윈도우 신드롬을 해결하기 위한 송신측 알고리즘 전송할 데이터를 어느정도 모아 한번에 전송하는 방법 송신측은 다음 세 조건중 하나가 만족되는 경우에만 세그먼트를 전송 응용 프로그램으로부터 받은 데이터를 버퍼에 저장하고 저장된 데이터의 크기가 MSS가 된 경우 수신측으로부터 확인 응답을 받은 경우 타이머가 완료된 경우(MSS 값이 상당이 클 경우 발생) 네트워크와 응용 프로그램의 데이터 처리 요구를 동시에 고려함 네트워크 처리 속도가 빠르다면 작은 세그먼트에 대해서도 신속한 처리가 가능 (ACK 수신) 네트워크 처리 속도가 느리다면 데이터를 모아서 전송, 네트워크의 불필요한 오버헤드를 줄일 수 있음 Clark 해결책 비정상 윈도우 신드롬을 해결하기 위한 수신측 알고리즘 수신측 윈도우 크기가 0이 되었을 경우 수신 버퍼가 최대 세그먼트 크기만큼 남았을 때 또는 버퍼의 여유 공간이 버퍼 크기의 절반이 될 때 까지 수신 윈도우 크기를 0으로 하여 ACK 전송 지연 확인 응답(Delayed Acknowledgement) 수신 버퍼에 충분한 공간이 생기기 전에는 확인 응답을 보내지 않음 수신측은 여분의 버퍼 공간을 확보할 수 있음 송신 측에서의 재전송이 계속 발생할 수 있으므로 200ms마다 ACK 송신 슬로우 스타트(Slow Start) 송신 측에서 네트워크 상태에 따라 흐름을 제어하는 기법 네트워크의 전송 처리 능력을 반영하기 위해 혼잡 윈도우(congestion window)를 두어 전송 속도를 제어 혼잡 윈도우는 확인 응답을 받을 때마다 증가 MSS 크기만큼의 세그먼트 단위 혼잡윈도우를 이용 cwnd=1에서부터 시작하여 ACK 세그먼트의 수신시마다 1씩 증가함 1개 세그먼트 송신 -&gt; 1개 ACK 세그먼트 수신 -&gt; 2개 세그먼트 송신 -&gt; 2개 ACK 세그먼트 수신 -&gt; 4개 세그먼트 송신 -&gt; 4개 ACK 세그먼트 수신 -&gt; ~ 실제 송신측에서 ACK 없이 전송 가능한 윈도우의 크기는 min(수신측 윈도우 크기, 혼잡 윈도우 크기) TCP 혼잡 제어 세그먼트 수가 네트워크 장비의 큐 용량보다 많이 도착했을 경우 큐는 오버플로우가 발생하여 세그먼트를 폐기함 (혼잡) 혼잡으로 인한 전송 지연때문에 세그먼트를 재전송한다면 이는 더 큰 혼잡을 초래한다 혼잡 윈도우 TCP는 네트워크 혼잡 상황을 반영하기 위해 혼잡 윈도우(cwnd)를 사용 임계값(SlowStart Threshold size)보다 작을 경우 cwnd는 2배씩 증가 혼잡 회피(Congestion Avoidence) 혼잡 윈도우 크기(cwnd)와 슬로우 스타트 임계값 값에 의해 제어 주어진 연결에 대해 cwnd는 1, 임계값은 65,535로 초기화 혼잡 윈도우 크기가 임계값에 도달할 경우 혼잡 회피 모드로 돌입 혼잡 회피 모드에서는 cwnd는 윈도우 안의 모든 세그먼트들이 확인 되었을 때에만 1씩 증가 혼잡 윈도우의 다중 감소 기법을 사용 혼잡이 타임아웃에 의해 발생했다면 cwnd는 1부터 재시작 임계값(ssth)는 cwnd의 절반으로 설정 슬로우 스타트 모드로 동작 중복 확인 응답(duplicated ACK)에 의해 혼잡이 발생한 경우 신속한 재전송 기법 사용 신속한 재전송 세그먼트가 누락된 경우 수신측은 순서가 다른 세그먼트를 받음 수신측은 누락된 세그먼트를 수신할 때까지 누락된 세그먼트를 요청하는 확인 응답을 반복 송신측은 누락된 세그먼트에 대한 확인 응답 수신시 두가지를 고려 세그먼트 전송 지연: 도착할 세그먼트이므로 재전송하지 않음 세그먼트 분실: 세 개의 중복된 확인응답 메시지를 수신할 때까지 기다리도록 권장 세 개의 중복된 확인응답(Duplicated ACK) 수신시 재전송 타이머의 타임아웃을 기다리지 않고 해당 세그먼트에 대한 재전송을 수행 RTO 값은 그대로 유지(네트워크 혼잡상황이 아닌 특정 세그먼트의 손실) cwnd는 현재의 $\\frac{1}{2}$로 변경, 혼잡 회피 모드로 동작 누락되었던 세그먼트 수신시 수신한 모든 세그먼트에 대해 누적 확인 응답을 전송 신속한 복구 손실된 세그먼트에 대해 신속한 재전송을 수행하면 혼잡 회피는 수행하지만 슬로우 스타트는 수행하지 않음 중복된 확인응답을 수신했다는 것은 다른 세그먼트는 정상적으로 수신되고 있음을 의미 두 호스트 간의 데이터 전송량을 급격히 줄이지 않기 위해 사용 출처: 정진욱, 김현철 공저. “TCP/IP와 인터넷”, pp 194-233. 2004. (주)생능출판사","link":"/2020/07/03/major/Internet%20Protocols/InternetProtocols-9/"},{"title":"Ch1. Wave Motion(1)- 빛, 파동","text":"빛빛은 입자이며 파동이다.빛은 파동이기 때문에 보강과 간섭이 작동하며, 빛은 입자이기도 하므로 빛의 양을 어둡게 하여 입자성을 확인할 수 있다. 파동매질을 통해 운동이나 에너지가 전달되는 현상물리적으로 위치를 이동하는게 아니라 변화와 섭동만 움직이고 매질은 상하로 움직일 뿐이다. 초음파와 횡파종파(Longitudinal wave) : 섭동의 방향이 파동의 진행방향과 같은 파동횡파(Transverse wave) : 섭동의 방향이 파동의 진행방향과 수직인 파동 파동방정식1차원 파동방정식1차원에서 속력이 일정한 파동.파동의 진행방향은 x, 진행속도는 v이라고 하자.매질은 상하로 움직일 뿐이므로 시간 t가 흐른 후의 펄스는 vt만큼 이동한 파동으로 볼 수 있다. \\psi(\\mathit{x,t})= \\mathit{f}(\\mathit{x-vt}) \\ \\ \\ +x축으로 진행하는 파동 \\\\\\\\ \\psi(\\mathit{x,t})= \\mathit{f}(\\mathit{x}+ \\mathit{vt}) \\ \\ \\ -x축으로 진행하는 파동 편미분을 이용한 1차원 파동방정식파동함수를 미분방정식으로 표현하기 위해서 x-domain과 t-domain에서 각각 편미분을 하여 관계를 확인한다. \\frac{\\partial ^2 \\psi}{\\partial x^2}=\\frac{1}{v^2}\\frac{\\partial^2 \\psi}{\\partial t^2}편미분을 통해 주어진 함수가 파동방정식인지 확인할 수 있다. ex)\\ \\ \\psi(x,t)=\\sin 2(x-3t) \\\\\\\\ \\frac{\\partial ^2 \\psi}{\\partial x^2}= -4\\sin2(x-3t) \\ \\ \\ \\ \\frac{\\partial^2 \\psi}{\\partial t^2}=-36A\\sin2(x-3t) \\\\\\\\ \\therefore \\frac{\\partial ^2 \\psi}{\\partial x^2} = \\frac{1}{v^2} \\frac{\\partial^2 \\psi}{\\partial t^2} \\ \\ (v=3)","link":"/2020/04/17/major/photonics/photonics-1/"},{"title":"Ch1. Wave Motion(2)- 조화파","text":"조화파 Harmonic Wavessin함수 형태의 유연한 파동 \\psi(x,t)=A\\sin k(x-vt)진폭진동의 최대 섭동은 A에 의하여 결정된다.이를 진폭(Amplitude)라고 한다. t-domain에서의 주기, 주파수, 각속도t-domain에서의 요소를 알아보기 위하여 x를 상수로 고정시키고 생각하였을 때 파동 방정식을 다음과 같이 정리할 수 있다. \\psi(x_{o},t)=A\\sin k(x_{o}-vt)=A\\sin kv(\\frac{x_{o}}{v}-t)주기조화파는 sin함수로 이루어져 있으며 주기는 $2\\pi$이다.이를 이용하여 파동은 $ \\frac {2\\pi}{kv} $의 주기로 진동함을 계산한다. A\\sin kv(\\frac{x_{o}}{v}-t)=A\\sin (kv(\\frac{x_{o}}{v}-t)+2\\pi)=A\\sin kv(\\frac{x_{o}}{v}-t+\\frac{2\\pi}{kv}) \\\\\\\\ \\therefore A\\sin kv(\\frac{x_{o}}{v}-t)=A\\sin kv(\\frac{x_{o}}{v}-(t-\\frac{2\\pi}{kv}))주기 $\\frac {2\\pi}{kv}$를 $\\tau $라 쓰고 tau라고 읽는다. 주파수t-domain에서의 주파수는 단위시간당 진동 수를 나타낸다.주기가 한번의 진동에 걸리는 시간이므로 주기의 역수를 취하여 주파수를 계산한다. \\nu = \\frac{1}{\\tau} = \\frac{kv}{2\\pi} \\left[Hz \\right]시간 주파수는 $\\nu$라고 쓰며 nu라고 읽는다. 속도를 의미하는 v와 혼동하지 않도록 주의해야한다. 각속도각속도는 각진동수로도 불리며 단위 시간당 파동이 진행하는 각도를 의미한다. \\omega=2\\pi\\nu=kv \\left[rad/s \\right]x-domain에서의 파장,파수,전파상수x-domain에서의 요소를 알아보기 위하여 t를 상수로 고정시키고 파동 방정식을 정리한다. \\psi(x,t_{o})=A\\sin k(x-vt_{o})=A\\sin kv(\\frac{x}{v}-t_{o})파장t-domain에서와 마찬가지로 sin함수의 주기 $2\\pi$를 이용하여 파동의 주기를 구할 수 있다. A\\sin k(x-vt_{o})=A\\sin (k(x-vt_{0})+2\\pi)=A\\sin k(x-vt_{0}+\\frac{2\\pi}{k}) \\\\\\\\ \\lambda = \\frac{2\\pi}{k}공간 도메인에서의 주기는 파동의 형태가 주기적으로 반복된 모양을 나타내는 구간이 존재함을 의미한다.따라서 공간 도메인에서의 주기를 파장(wave length)라 부를 수 있다. 파수x-domain에서의 주파수는 1m의 공간 안에서 파동이 몇 번의 주기를 갖는가를 표현한다. \\kappa = \\frac{1}{\\lambda} = \\frac{k}{2\\pi}단위 길이 당 파동은 주파수만큼의 파동을 갖는다. 이를 파수(Wave Number)라고도 한다.파수는 $ \\kappa $라 쓰고 카파라 읽는다. k와 혼동하지 않도록 주의해야한다. 전파상수x-domain에서의 각속도는 1m당 파동이 진행하는 각도를 의미한다.이를 전파 상수(Propagation Number)라고 하며 이는 파동방정식으로 주어진 $\\psi(x,t)=A\\sin k(x-vt) $로부터 k임을 알 수 있다. 위상파동은 임의의 시간 t에서 vt만큼 이동한 f(x)의 펄스를 확인할 수 있다.또한 파동은 매질을 상하로 움직이므로 매질의 위치 x에 따라 변위가 변할 수 있다.따라서 매질의 변위를 결정하는 것은 k(x-vt)이며, 이를 위상(Phase) 혹은 상이라고 한다.파동은 위상이 0에서 시작할 수 있지만 다른 위상으로부터 시작할 수 있다.이를 초기 위상(Initial Phase)라 하며 $\\epsilon $을 추가하여 표기한다. \\psi = A \\sin (kx-\\omega t + \\epsilon) = A\\sin \\phi속도위상은 x와 t의 함수이다. 따라서 위상의 변화율은 x의 변화율과 t의 변화율로 표현할 수 있고, 변화율이 0이 될때 속도를 계산할 수 있다. \\triangle \\phi = \\triangle x \\frac{\\partial \\phi}{\\partial x} + \\triangle t \\frac{\\partial \\phi}{\\partial t} \\\\\\\\ \\frac{\\triangle x}{\\triangle t} = \\frac{-\\frac{\\partial \\phi}{\\partial t}}{\\frac{\\partial \\phi}{\\partial x}} = \\frac{\\omega}{k} = \\frac{2\\pi \\nu}{\\frac{2\\pi}{\\lambda}}=\\lambda \\nu = v각속도/전파상수, 파장 x 주파수가 속도라는 점을 기억하자. 조화파의 표현조화파는 각 도메인의 파장,주파수,각속도를 이용하여 다음과 같이 표현할 수 있다. \\psi = A\\sin k(x \\mp vt) \\\\\\\\ \\psi = A\\sin 2\\pi(\\frac{x}{\\lambda} \\mp \\frac{t}{\\tau})\\\\\\\\ \\psi = A\\sin 2\\pi(\\kappa x \\mp vt)\\\\\\\\ \\psi = A\\sin (kx \\mp \\omega t)\\\\\\\\ \\psi = A\\sin 2\\pi v(\\frac{x}{v} \\mp t)","link":"/2020/04/19/major/photonics/photonics-2/"},{"title":"Ch1.Wave Motion(3)- 중첩의 원칙, 복소수 표현법, 3차원 파동방정식","text":"중첩의 원칙파동은 liner system이다.이는 두 파동의 합은 단순한 위치와 시간에서의 합으로 이루어진다는 뜻이다. wave1 \\ \\ \\ \\frac{\\partial ^2 \\psi_{1}}{\\partial x^2}=\\frac{1}{v^2}\\frac{\\partial^2 \\psi_{1}}{\\partial t^2} \\\\\\\\ wave2 \\ \\ \\ \\frac{\\partial ^2 \\psi_{2}}{\\partial x^2}=\\frac{1}{v^2}\\frac{\\partial^2 \\psi_{2}}{\\partial t^2} \\\\\\\\ wave1 + wave2 \\ \\ \\ \\frac{\\partial ^2 (\\psi_{1}+\\psi_{2})}{\\partial x^2}=\\frac{1}{v^2}\\frac{\\partial^2 (\\psi_{1}+\\psi_{2})}{\\partial t^2} \\\\\\\\그러나 두 파동의 위상에 따라 합의 결과가 달라질 수 있다.이를 간섭(Interference)라 하며, 두 파동이 합하여 진폭이 증가할 경우 보강 간섭(In-Phase), 진폭이 감소한 경우 상쇄 간섭(Out-of-Phase)라 한다. 복소수 표현법(phasor)위상이 다른 두 조화파의 합은 복소수 표현법을 이용하여 쉽게 계산할 수 있다. \\psi=A\\sin (kx-\\omega t +epsilon^{'})\\\\\\\\ \\psi=A\\cos (\\omega t -kx +epsilon)\\\\\\\\ e^{i \\theta}=\\cos \\theta +i\\sin\\theta \\\\\\\\ \\psi(x,t)=Re[Ae^{i(\\omega t-kx+\\epsilon)}]=Re[Ae^{i\\theta}]복소수로 표현된 파동은 복소수의 실수부만이 물리적인 의미를 가지므로편의상 파동을 $Ae^{i(\\omega t-kx+\\epsilon)}=Ae^{i \\phi}$로 표현하기도 하며 다음과 같이 phasor형태로 파동을 표기할 수 있다. A\\angle\\phi\\\\\\\\ A\\angle(-kx+\\epsilon)=Ae^{i(-kx+\\epsilon)}이러한 방식으로 표현하는 경우 대게 $\\omega t$가 생략되는 경우이며, $-\\omega t$가 생략되어 표현된 경우도 있으니 주의하여야 한다. 3차원 파동방정식1차원 파동방정식은 x와 t에 대하여 파동을 나타낸 것이다.3차원 파동방정식의 경우 x,y,z,t에 대하여 파동을 나타내며, 이에 따라 벡터의 개념이 사용된다. 위치벡터특정 시간 t대한 파동의 위치를 위치벡터라 한다.(x,y,z)의 위치에 대해 $ \\overrightarrow{r}=x\\widehat{i}+y\\widehat{j}+z\\widehat{k}$의 위치벡터로 표현할 수 있다. 파수 벡터(Propagation Vector)파동의 진행방향을 각 성분으로 표시한 벡터이다.$\\overrightarrow{k}=k_{x}\\widehat{i}+k_{y}\\widehat{j}+k_{z}\\widehat{k}$로 파동의 진행방향을 표현할 수 있다.파수 벡터는 전파 상수의 3차원 확장이다.파수 벡터는 각 축으로부터의 각도에 의하여 방향이 결정된다. 파면(Wavefront)파면은 같은 위상의 점들을 이어 만든 면이다.1차원 파동에서 주어진 시간에 대해 파동을 선으로 표현하였듯 3차원 파동에서는 주어진 시간에 대해 파동을 면으로서 표현할 수 있다. 평면파(plane wave)평면파는 파면이 항상 평면인 파동을 뜻한다.평면파는 진폭이 일정하고 Propagation vector와 수직인 면의 위치벡터가 같은 위상을 갖는다. \\psi(\\overrightarrow{r},t)=Ae^{i(\\overrightarrow{k} \\cdot \\overrightarrow{r} \\mp \\omega t)} \\\\\\\\ \\psi(\\overrightarrow{r})=Ae^{i\\overrightarrow{k} \\cdot \\overrightarrow{r}} \\\\\\\\ \\psi(x,y,z)=Ae^{i(k_{x}x+k_{y}y+k_{z}z )} 평면파의 3차원 미분방정식1차원에서 편미분을 이용하여 파동방정식을 나타내었다.같은 방식으로 3차원 평면파의 미분방정식을 이끌어낼 수 있다. \\psi = Ae^{j\\overrightarrow{k} \\cdot \\overrightarrow{r}}=Ae^{j(\\overrightarrow{k} \\cdot \\overrightarrow{r}-\\omega t)}=Ae^{j(k_{x}x+k_{y}y+k_{z}z)} \\\\\\\\ \\triangledown^2 \\psi = -(k_{x}^2+k_{y}^2+k_{z}^2)Ae^{j(k_{x}x+k_{y}y+k_{z}z)} \\\\\\\\ \\frac{\\partial^2 \\psi}{\\partial t^2}=(-\\omega^2)Ae^{j(k_{x}x+k_{y}y+k_{z}z)} \\\\\\\\ \\omega = 2\\pi \\nu, \\frac{\\omega^2}{v^2}=\\frac{2\\pi \\nu}{v}^2=\\frac{2\\pi \\nu}{\\nu \\lambda}=\\frac{2\\pi}{\\lambda}=k^2\\\\\\\\ \\therefore \\triangledown^2 \\psi=\\frac{1}{v^2} \\frac{\\partial^2 \\psi}{\\partial t^2} \\ \\ \\ (\\triangledown^2 = (\\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}+\\frac{\\partial^2}{\\partial z^2}))구면파(Spherical waves)구면파는 파면이 구를 이루는 파동이다.파면이 구면이므로 구면파는 진행할수록 거리에 반비례하여 진폭이 감소하며 아래의 파동방정식을 갖는다. \\psi (\\overrightarrow{r})=\\frac{A}{r}e^{ikr}","link":"/2020/04/19/major/photonics/photonics-3/"},{"title":"Ch 2.Electromagnetic Theory, Photons, and Light (1) - 맥스웰 방정식, 횡파","text":"맥스웰 방정식맥스웰 방정식은 페러데이, 앙페르, 가우스 법칙을 전기장과 자기장의 통합으로 정리한 방정식이다.맥스웰 방정식은 적분 형태(Integral form)와 미분 형태(Point form)으로 표현한다. 각 방정식이 표현하는 바는 다음과 같다. 페러데이 법칙: 시간에 따라 자기장이 변하면 전기장을 유도한다 앙페르 법칙: 시간에 따라 전기장이 변하면 자기장을 유도한다. 가우스 법칙(전기장): 나가는 전하의 양과 들어오는 전하의 양은 같다. 가우스 법칙(자기장): 음전하와 양전하가 따로 존재할 수 없다. 전하와 전류가 없는 자유공간에서 맥스웰 방정식으로부터 다음과 같이 파동방정식을 유도할 수 있다. \\triangledown\\cdot\\overrightarrow{E}=0 \\ \\ , \\ \\ \\triangledown\\cdot\\overrightarrow{B}=0 \\\\\\\\ \\triangledown\\times\\triangledown\\times\\overrightarrow{E}=\\triangledown(\\triangledown\\cdot\\overrightarrow{E})-\\triangledown^2\\overrightarrow{E}=-\\triangledown^2\\overrightarrow{E} \\\\\\\\ \\triangledown\\times\\triangledown\\times\\overrightarrow{E}=\\triangledown\\times(-\\frac{\\partial\\overrightarrow{B}}{\\partial t}) = -\\frac{\\partial(\\triangledown\\times\\overrightarrow{B})}{\\partial t} = -\\mu_o \\epsilon_0\\frac{\\partial^2\\overrightarrow{E}}{\\partial t^2}\\\\\\\\ \\triangledown\\times\\triangledown\\times\\overrightarrow{B}=\\triangledown(\\triangledown\\cdot\\overrightarrow{B})-\\triangledown^2\\overrightarrow{B}=-\\triangledown^2\\overrightarrow{B} \\\\\\\\ \\triangledown\\times\\triangledown\\times\\overrightarrow{B}=\\triangledown\\times(\\mu_o\\epsilon_o\\frac{\\partial\\overrightarrow{E}}{\\partial t}) = \\mu_o \\epsilon_o\\frac{\\partial(\\triangledown\\times\\overrightarrow{E})}{\\partial t}=- \\frac{\\partial^2\\overrightarrow{B}}{\\partial t^2} \\\\\\\\ \\therefore \\triangledown^2\\overrightarrow{E} = \\mu_o \\epsilon_0\\frac{\\partial^2\\overrightarrow{E}}{\\partial t^2}, \\ \\ \\ \\ \\triangledown^2\\overrightarrow{B} = \\mu_o \\epsilon_0\\frac{\\partial^2\\overrightarrow{B}}{\\partial t^2}이는 3차원 파동방정식이 $\\frac{\\partial^2 \\psi}{\\partial x^2}+\\frac{\\partial^2\\psi}{\\partial y^2}+\\frac{\\partial^2\\psi}{\\partial z^2}=\\frac{1}{v^2} \\frac{\\partial^2 B}{\\partial t^2}$이므로 전기장과 자기장은 파동이며 전기장과 자기장의 자유공간에서의 속도$v=\\frac{1}{\\sqrt{\\mu_o\\epsilon_o}}$임을 알 수 있다. 맥스웰은 페퍼와 콜라우슈의 실험결과를 사용하여 $\\epsilon_o \\approx 8.85 \\times 10^-12 \\ s^2\\cdot C^2/m^3 \\cdot kg, \\ \\ \\mu_o \\approx 4\\pi \\times 10^-7 \\ m\\cdot kg/C^2$의 값을 식에 대입하였고, 이를 통해 $v\\approx 3 \\times 10^8$임을 구하였다. 따라서 전기장과 자기장의 속도가 빛의 속도와 같음을 통하여 빛은 전자기파라는 사실을 알 수 있다.(1983년 파리에서 열린 제 17차 국제도량형 총회에서 길이의 단위로 미터가 새로 확정되며 정해진 빛의 속도는 $c=2.99792458 \\times 10^8$이다.) 횡파(Transverse Wave)자유공간에서 x축의 양의 방향으로 진행하는 평면파를 생각해보자.맥스웰 방정식에 의해 다음과 같이 정리할 수 있다. \\frac{\\partial E}{\\partial x}+\\frac{\\partial E}{\\partial y}+\\frac{\\partial E}{\\partial z}=\\frac{\\partial E_x}{\\partial x}=0진행파가 양의 x 방향으로 진행하므로 $E_x =0$임을 의미하며 따라서 전기장 $\\overrightarrow{E}$는 전자기파의 방향에 수직함을 알 수 있다. 전기장의 방향을 y축과 평행하다고 가정할 때, $\\overrightarrow{E}=\\hat{j}E_y(x,t)$이고, 맥스웰 방정식에 의하여 다음과 같이 식을 정리할 수 있다. \\triangledown \\times \\overrightarrow{E} = - \\frac{\\partial \\overrightarrow{B}}{\\partial t}\\\\\\\\ \\triangledown \\times \\overrightarrow{E} = \\hat{k}\\frac{\\partial E_y}{\\partial x}\\\\\\\\ \\therefore \\ \\ \\frac{\\partial E_y}{\\partial x}= -\\frac{\\partial \\overrightarrow{B_z}}{\\partial t}이를 통하여 평면파가 x축의 방향으로 진행하고, 전기장이 y축과 평행할 때, 자기장이 z방향 성분만을 가지고 평면파는 자유공간에서 횡파임을 확인할 수 있다.평면파는 조화파이므로 푸리에 방법을 이용하여 전기장과 자기장을 계산할 수 있다. E_y(x,t) = E_oy \\cos[\\omega(t-x/c)+\\epsilon]\\\\\\\\ \\frac{\\partial E_y}{\\partial x}= -\\frac{\\partial \\overrightarrow{B_z}}{\\partial t}, \\ \\ \\ \\frac{\\partial E_y}{\\partial x}=\\frac{\\omega}{c}E_oy \\sin[\\omega(t-x/c)+\\epsilon]\\\\\\\\ \\therefore B_z=\\frac{1}{c}E_oy\\cos[\\omega(t-x/c)+\\epsilon]위 식으로부터 전기장과 자기장의 위상이 같고, 두 진폭은 비례관계를 가짐을 알 수 있다. E_y = cB_z\\\\\\\\ \\hat{E}\\times\\hat{B}=(전자기파의 진행방향)","link":"/2020/04/22/major/photonics/photonics-4/"},{"title":"Ch 2.Electromagnetic Theory, Photons, and Light (2) - 포인팅 벡터, 복사조도","text":"전자기파의 에너지전자기파의 에너지밀도공간상의 어떤 영역에 전자기파가 존재한다면 단위체적당 복사 에너지, 즉 에너지 밀도 u가 있다고 할 수 있다.전자기파가 에너지를 저장할 수 있다고 가정하여 에너지가 퍼져나가는 곳을 보도록 하자.전기장 $\\overrightarrow{E}$의 에너지 밀도와 자기장 $\\overrightarrow{B}$의 에너지 밀도는 다음과 같다. u_E = \\frac{\\epsilon_o}{2}E^2 , \\ \\ \\ u_B = \\frac{1}{2\\mu_o}B^2관계식 $E = cB$과 $c = \\sqrt{\\epsilon_o \\mu_o}$를 사용하여 $u_E = u_B$의 식을 확인할 수 있다.따라서 공간상에서 전파하는 전자기파는 에너지를 전기장과 자기장 형태로 나누어 가지고 있으며, 총 에너지 밀도는 전기장과 자기장의 에너지 밀도의 합으로 표현된다. u = u_E+u_B = \\epsilon_o E^2 = \\frac{1}{\\mu_o}B^2 포인팅 벡터단면적 A를 광속으로 통과하는 전자기파가 존재한다고 가정하자.시간 간격 $\\triangle t$를 생각하면 원기둥 속에 들어있는 에너지 $u(c \\triangle t A)$는 단면적 A를 통과하게 된다는 것을 알 수 있다. 에너지의 흐름을 표현하기 위해 단위면적을 통해 단위시간에 전달하는 에너지를 $S$ 기호를 통해 나타도록한다.이는 에너지와 운동량을 나타내므로 스칼라 값은 다음과 같이 에너지를 단위시간과 단위 면적으로 나누어 계산할 수 있다. S = \\frac{uc\\triangle t A}{\\triangle t A} = uc = \\frac{1}{\\mu_o}EB이전 횡파(Transverse Wave)로부터 전자기파의 진행방향을 자기장과 전기장 벡터의 외적으로 표현한 바 있다.에너지의 진행방향은 전자기파의 진행방향이고, 자기장과 전기장은 서로 수직이므로 에너지의 벡터는 자기장과 전기장의 외적으로서 다음과 같이 표현할 수 있다. \\overrightarrow{S} = \\frac{1}{\\mu_o} \\overrightarrow{E} \\times \\overrightarrow{B} = c^2\\epsilon_o \\overrightarrow{E} \\times \\overrightarrow{B}이러한 에너지 벡터 $\\overrightarrow{S}$의 크기는 벡터와 평행한 법선을 갖는 단위면적을 통과하는 빛의 파워로, 포인팅 벡터(Poyting Vector)라 한다.공간 상에서 $\\overrightarrow{k}$의 방향으로 전파하는 조화파동에서 이를 적용하면 다음과 같이 표현할 수 있다. \\overrightarrow{E} = \\overrightarrow{E}_o \\cos (\\overrightarrow{k}\\cdot\\overrightarrow{r} - \\omega t) \\\\\\\\ \\overrightarrow{B} = \\overrightarrow{B}_o \\cos (\\overrightarrow{k}\\cdot\\overrightarrow{r} - \\omega t) \\\\\\\\ \\overrightarrow{S} = c^2\\epsilon_o \\overrightarrow{E}_o \\overrightarrow{B}_o \\cos^2(\\overrightarrow{k} \\cdot \\overrightarrow{r} - \\omega t)포인팅 벡터는 단위시간당 단위면적당 에너지의 흐름을 나타낸다. 복사조도(Irradiance)어떤 면을 비추는 빛의 총량을 나타낼 때 I라고 표기하는 복사조도(irradiance),단위시간당 단위면적당 평균 에너지로 표현한다.포인팅 벡터는 시간에 따라 에너지의 흐름이 변하므로 시간에 대해 평균을 계산한다면 이는 평균 에너지, 즉 복사조도로 표현할 수 있다. I = \\langle |\\overrightarrow{S}|\\rangle_T \\\\\\\\= \\frac{1}{T}\\int_T c^2\\epsilon_o \\overrightarrow{E}_o \\times \\overrightarrow{B}_o \\cos^2(\\overrightarrow{k}\\cdot\\overrightarrow{r}_o-\\omega t)dt \\\\\\\\= c^2\\epsilon_o \\overrightarrow{E}_o \\times \\overrightarrow{B}_o (\\frac{1}{2})=c^2\\epsilon_o E_o \\frac{E_o}{c} \\frac{1}{2} \\\\\\\\=\\frac{c\\epsilon_o}{2}E_o^2 = c\\epsilon_o \\langle E^2 \\rangle_T복사조도는 전기장의 진폭의 제곱에 비례하며 전기장은 자기장보다 전하의 에너지에 크게 관여한다.따라서 전기장은 광파(optical field)라 하고 복사조도를 전기장을 이용하여 표현한다.","link":"/2020/04/25/major/photonics/photonics-5/"},{"title":"Ch 2.Electromagnetic Theory, Photons, and Light (3) - 광자, 복사, 분산","text":"광자(Photon)빛은 파동으로서의 성질뿐만아니라 입자로서의 성질을 갖고 있다.19세기 초 토마스 영의 이중 슬릿 실험을 통해 빛이 무늬를 생성하면서, 빛의 입자성이 증명되었는데, 빛은 일반적인 물체와는 다르게 입자를 직접 볼 수 없었다.이에 빛의 입자성을 표현하기 위해 광자(Photon)의 개념이 도입되었으며, 빛을 양자화하여 표현하였다.광자는 속도가 c일때만 안정적이며, 전하가 존재하지 않고 질량이 없는 기본 입자로 존재한다. 복사(Radiation)모든 물체는 복사선에 의하여 에너지를 방출할 수 있으며 전자기파로써 방출되어 전달되는 에너지를 복사(Radiation)이라고 한다.전자기파 복사는 넓은 파장대와 주파수대를 갖고 있지만 진공 중에서 파장에 관계없이 일정한 속도로 움직인다.전자기장에서 파동이 나타나고, 전하가 전기장을 만드는 것이므로 복사는 불균일한 이동전하라는 점을 생각할 수 있다. 전기쌍극자 복사(Electric Dipole Radiation)전자기파의 발생은 전하를 띈 입자가 가속도 운동을 하면서 발생한다.가속도 운동을 하는 전하를 띈 입자에 의해서만 전하에 따른 전기장이 시간에 따라 변하고 자기장 또한 시간에 따라 변하므로 전자기파의 발생을 확인할 수 있다. 양전하와 음전하로 이루어진 쌍극자는 극성에 의하여 전하는 진동을 한다. (쌍극자 모멘트)이러한 진동은 가속도 운동이므로 자기장과 전기장을 생성하며 전자기파를 발생시킨다. 원자로부터 나오는 빛의 방출(resonant scattering)가장 낮은 에너지 상태(Ground State)의 Dipole은 어떤 이유로든지 원자에 에너지를 주게 되면 바닥상태보다 높은 에너지 상태인 들뜬 상태(Excited state) 의 분포를 갖는다.이러한 상태에서 들뜬 상태는 불안정한 상태이므로 에너지를 방출하며 바닥상태로 돌아가는데, 에너지의 방출은 다양한 형태로 방출되지만 에너지 차이에 해당하는 만큼 광자(photon)를 발생시키며 이는 전자기파의 원천으로서 작동하게 된다.이러한 에너지의 방출을 resonant scattering이라고 한다. 물질 속에서의 빛특정 매질에서(공기중, 물, 유리) 매질에 입자가 존재하므로 빛의 속도는 자유공간에서의 빛의 속도보다 느림을 유추할 수 있다.자유공간에서의 빛의 속도는 $c = 3 \\times 10^8 km/s$임을 알고 있다.빛의 속도는 맥스웰 방정식으로부터 계산한 $c=\\frac{1}{\\sqrt{\\mu_o\\epsilon_o}}$에 의하여 계산된 것으로, 자유공간에서의 투자율 $\\mu_o$, 유전율 $\\epsilon_o$에 의해 결정된다.특정 매질에서의 속도 $v = \\frac{1}{\\sqrt{\\epsilon \\mu}}$이며진공 속에서의 빛의 속도와 매질에서의 빛의 속도의 비를 절대굴절률 n이라 하며 다음과 같이 표현한다. n = \\frac{c}{v} = \\sqrt{\\frac{\\epsilon \\mu}{\\epsilon_o \\mu_o}}이러한 굴절률은 상대유전율 $K_E = \\frac{\\epsilon}{\\epsilon_o}$와 상대투자율 $K_M = \\frac{\\mu}{\\mu_o}$으로 표현하여 다음과 같이 표현할 수 있다. n = \\sqrt{K_E K_M}빛의 주파수 영역에서는 대부분의 물질들의 상대 투자율 $K_M$이 $10^4$이내에 있어 근사적으로 $\\sqrt{K_M}=1$의 값을 갖고, 따라서 $n = \\sqrt{K_E}$로서 맥스웰 관계식으로 표현할 수 있다.$K_E$는 정적 유전상수(static dielectric constant)이지만 이는 입사하는 빛의 진동수에 따라 달라지며 이는 파장과 연관되어 있다.굴절률 n이 파장에 따라 달라지는 것을 분산(dispersion)이라고 한다. 분산(Dispersion)분자에 자기장이 가해지는 경우 음전하와 양전하가 나뉘어지는 분극이 발생한다.이에 내부에서 분극이 발생하며 내부에서 전기장이 생성된다.총 전기장은 외부에서 가해지는 전기장과 내부에서 발생한 전기장의 합이다.대부분의 매질에서 전기분극은 다음의 관계식을 만족한다. P = Qd \\\\\\\\ (\\epsilon - \\epsilon_o)\\overrightarrow{E} = \\overrightarrow{P}원자에서 전자구름은 양전하를 갖는 핵의 인력 때문에 평형상태를 유지하면서 형성된다. 원자 내부의 상호작용을 모두 고려하지 않더라도 계는 붕괴되지 않으며 계를 원상으로 회복하는 힘 F가 존재한다.일반적으로 매질은 많은 원자들의 집합으로 볼 수 있는데, 광파가 이곳에 입사하면 각 원자는 가해진 전기장 E(t)에 따라 진동하는 진동자(Oscillator)와 같이 행동한다.그림과 같이 전하의 핵에 각 방향으로 용수철이 메달려 있다고 생각했을 때 전하가 $q_e$인 전자에 작용하는 진동수 $\\omega$인 조화파에 의한 힘 $F_E$는 다음과 같다. F_E = q_e E(t) = q_e E_o \\cos \\omega t이러한 구동력에 대한 복원력은 방향을 x축의 양의 방향이라고 가정하였을 때 다음과 같다. F = -m_e {\\omega_o}^2 x구동력과 복원력은 서로 반대방향으로 생성되며, 물체에 작용하는 모든 힘은 질량과 가속도의 곱과 같다는 뉴턴의 제2법칙을 통해 다음과 같은 식을 얻을 수 있다. q_e E_o \\cos \\omega t - m_e\\omega^2 x = m_e\\frac{d^2 x}{dt^2}식이 성립하기 위해서는 x의 2차미분은 x와 비슷한 형식을 갖추어야 한다.따라서 x(t)를 $x_o \\cos \\omega t$로 가정하여 다음과 같이 식을 풀 수 있다. q_e E_o \\cos \\omega t -m_e {\\omega_o}^2x_o\\cos\\omega t = -m_e \\omega^2 x_o \\cos\\omega t \\\\\\\\ \\therefore x_o=\\frac{q_e E_o / m_e}{\\omega_o ^2 - \\omega^2}, \\\\\\\\ x(t) = \\frac{q_e/ m_e}{\\omega_o ^2 - \\omega^2} E_o \\cos \\omega t = \\frac{q_e/ m_e}{\\omega_o ^2 - \\omega^2} E(t)이는 양전하를 가진 핵과 음전하를 가진 전자구름 사이의 상대적인 변위를 의미하며 $\\omega$의 크기에 따라 x(t)는 방향이 변한다.따라서 쌍극자 모멘트는 N개의 쌍극자에 대하여 분극과 이를 이용하여 구한 정적 유전상수 $K_E$는 다음과 같다. P = q_e xN = \\frac{ q^2 _eNE/m_e}{(\\omega_o ^2 - \\omega)} \\\\\\\\ (\\epsilon - \\epsilon_o)E = \\frac{ q^2 _eNE/m_e}{(\\omega_o ^2 - \\omega)}, \\\\\\\\ K_E \\epsilon_o - \\epsilon_o = \\frac{ q^2 _eN/m_e}{(\\omega_o ^2 - \\omega)},\\\\\\\\ \\therefore K_E = 1+\\frac{Nq_e ^2}{\\epsilon_o m_e} (\\frac{1}{\\omega_o ^2 -\\omega^2})$K_E = n^2$의 식으로부터 굴절률 n을 다음과 같이 $\\omega$의 함수인 분산 방정식(Dispersion Equation)으로 표현할 수 있다. n^2(\\omega) = 1+\\frac{Nq_e ^2}{\\epsilon_o m_e} (\\frac{1}{\\omega_o ^2 -\\omega^2})","link":"/2020/04/25/major/photonics/photonics-6/"}],"tags":[{"name":"boj","slug":"boj","link":"/tags/boj/"},{"name":"1005","slug":"1005","link":"/tags/1005/"},{"name":"ACMCraft","slug":"ACMCraft","link":"/tags/ACMCraft/"},{"name":"1009","slug":"1009","link":"/tags/1009/"},{"name":"1018","slug":"1018","link":"/tags/1018/"},{"name":"1007","slug":"1007","link":"/tags/1007/"},{"name":"1012","slug":"1012","link":"/tags/1012/"},{"name":"1021","slug":"1021","link":"/tags/1021/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Component","slug":"Component","link":"/tags/Component/"},{"name":"1032","slug":"1032","link":"/tags/1032/"},{"name":"1037","slug":"1037","link":"/tags/1037/"},{"name":"Autowired","slug":"Autowired","link":"/tags/Autowired/"},{"name":"Ioc","slug":"Ioc","link":"/tags/Ioc/"},{"name":"major","slug":"major","link":"/tags/major/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"sorting","slug":"sorting","link":"/tags/sorting/"},{"name":"BubbleSort","slug":"BubbleSort","link":"/tags/BubbleSort/"},{"name":"InsertionSort","slug":"InsertionSort","link":"/tags/InsertionSort/"},{"name":"SelectionSort","slug":"SelectionSort","link":"/tags/SelectionSort/"},{"name":"MergeSort","slug":"MergeSort","link":"/tags/MergeSort/"},{"name":"QuickSort","slug":"QuickSort","link":"/tags/QuickSort/"},{"name":"ShellSort","slug":"ShellSort","link":"/tags/ShellSort/"},{"name":"HeapSort","slug":"HeapSort","link":"/tags/HeapSort/"},{"name":"analysis","slug":"analysis","link":"/tags/analysis/"},{"name":"Big O","slug":"Big-O","link":"/tags/Big-O/"},{"name":"Big Omega","slug":"Big-Omega","link":"/tags/Big-Omega/"},{"name":"Big Theta","slug":"Big-Theta","link":"/tags/Big-Theta/"},{"name":"OSI","slug":"OSI","link":"/tags/OSI/"},{"name":"winsock","slug":"winsock","link":"/tags/winsock/"},{"name":"Repeater","slug":"Repeater","link":"/tags/Repeater/"},{"name":"Hub","slug":"Hub","link":"/tags/Hub/"},{"name":"Bridge","slug":"Bridge","link":"/tags/Bridge/"},{"name":"switch","slug":"switch","link":"/tags/switch/"},{"name":"Router","slug":"Router","link":"/tags/Router/"},{"name":"Gateway","slug":"Gateway","link":"/tags/Gateway/"},{"name":"IP","slug":"IP","link":"/tags/IP/"},{"name":"IP Protocol","slug":"IP-Protocol","link":"/tags/IP-Protocol/"},{"name":"ARP","slug":"ARP","link":"/tags/ARP/"},{"name":"ICMP","slug":"ICMP","link":"/tags/ICMP/"},{"name":"IP Packet","slug":"IP-Packet","link":"/tags/IP-Packet/"},{"name":"IP Header","slug":"IP-Header","link":"/tags/IP-Header/"},{"name":"TCP","slug":"TCP","link":"/tags/TCP/"},{"name":"TCP Header","slug":"TCP-Header","link":"/tags/TCP-Header/"},{"name":"IPv6","slug":"IPv6","link":"/tags/IPv6/"},{"name":"photonic","slug":"photonic","link":"/tags/photonic/"}],"categories":[{"name":"코딩테스트","slug":"코딩테스트","link":"/categories/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/"},{"name":"FrameWork","slug":"FrameWork","link":"/categories/FrameWork/"},{"name":"스프링","slug":"FrameWork/스프링","link":"/categories/FrameWork/%EC%8A%A4%ED%94%84%EB%A7%81/"},{"name":"외전","slug":"FrameWork/스프링/외전","link":"/categories/FrameWork/%EC%8A%A4%ED%94%84%EB%A7%81/%EC%99%B8%EC%A0%84/"},{"name":"1장 - IOC 컨테이너","slug":"FrameWork/스프링/1장-IOC-컨테이너","link":"/categories/FrameWork/%EC%8A%A4%ED%94%84%EB%A7%81/1%EC%9E%A5-IOC-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88/"},{"name":"major","slug":"major","link":"/categories/major/"},{"name":"알고리즘","slug":"major/알고리즘","link":"/categories/major/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"인터넷 프로토콜","slug":"major/인터넷-프로토콜","link":"/categories/major/%EC%9D%B8%ED%84%B0%EB%84%B7-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/"},{"name":"알고리즘 분석","slug":"major/알고리즘/알고리즘-분석","link":"/categories/major/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B6%84%EC%84%9D/"},{"name":"정렬 알고리즘","slug":"major/알고리즘/정렬-알고리즘","link":"/categories/major/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/"},{"name":"4장 - TCP","slug":"major/인터넷-프로토콜/4장-TCP","link":"/categories/major/%EC%9D%B8%ED%84%B0%EB%84%B7-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/4%EC%9E%A5-TCP/"},{"name":"1장 - OSI와 인터네트워킹 장비","slug":"major/인터넷-프로토콜/1장-OSI와-인터네트워킹-장비","link":"/categories/major/%EC%9D%B8%ED%84%B0%EB%84%B7-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/1%EC%9E%A5-OSI%EC%99%80-%EC%9D%B8%ED%84%B0%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%82%B9-%EC%9E%A5%EB%B9%84/"},{"name":"광자공학기초","slug":"major/광자공학기초","link":"/categories/major/%EA%B4%91%EC%9E%90%EA%B3%B5%ED%95%99%EA%B8%B0%EC%B4%88/"},{"name":"5장 - 윈도우 네트워크 프로그래밍","slug":"major/인터넷-프로토콜/5장-윈도우-네트워크-프로그래밍","link":"/categories/major/%EC%9D%B8%ED%84%B0%EB%84%B7-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/5%EC%9E%A5-%EC%9C%88%EB%8F%84%EC%9A%B0-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"},{"name":"2장 - IP","slug":"major/인터넷-프로토콜/2장-IP","link":"/categories/major/%EC%9D%B8%ED%84%B0%EB%84%B7-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/2%EC%9E%A5-IP/"},{"name":"3장 - IPv6","slug":"major/인터넷-프로토콜/3장-IPv6","link":"/categories/major/%EC%9D%B8%ED%84%B0%EB%84%B7-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C/3%EC%9E%A5-IPv6/"},{"name":"Ch 1. Wave Motion","slug":"major/광자공학기초/Ch-1-Wave-Motion","link":"/categories/major/%EA%B4%91%EC%9E%90%EA%B3%B5%ED%95%99%EA%B8%B0%EC%B4%88/Ch-1-Wave-Motion/"},{"name":"Ch 2. Electromagnetic Theory, Photons, and Light","slug":"major/광자공학기초/Ch-2-Electromagnetic-Theory-Photons-and-Light","link":"/categories/major/%EA%B4%91%EC%9E%90%EA%B3%B5%ED%95%99%EA%B8%B0%EC%B4%88/Ch-2-Electromagnetic-Theory-Photons-and-Light/"}]}